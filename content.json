{"meta":{"title":"Lynch's Blogs","subtitle":"记录生活与学习的点点滴滴","description":"个人博客","author":"AmazingLynch","url":"http://amazinglynch.com"},"pages":[{"title":"tags","date":"2017-11-16T14:45:52.000Z","updated":"2017-11-16T14:55:53.184Z","comments":false,"path":"tags/index.html","permalink":"http://amazinglynch.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-11-16T14:55:09.000Z","updated":"2017-11-16T14:56:28.812Z","comments":false,"path":"categories/index.html","permalink":"http://amazinglynch.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Node中的内存控制","slug":"Node中的内存控制","date":"2017-11-24T02:49:29.000Z","updated":"2017-11-24T12:16:14.528Z","comments":true,"path":"2017/11/24/Node中的内存控制/","link":"","permalink":"http://amazinglynch.com/2017/11/24/Node中的内存控制/","excerpt":"V8V8的内存限制在Node中通过JavaScript使用内存会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB）。这种限制下，会导致Node无法直接操作大内存对象。造成这种限制的主要原因在于Node基于V8构建，所以在Node中使用JavaScript对象都是通过V8自己的方式来进行分配和管理的。","text":"V8V8的内存限制在Node中通过JavaScript使用内存会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB）。这种限制下，会导致Node无法直接操作大内存对象。造成这种限制的主要原因在于Node基于V8构建，所以在Node中使用JavaScript对象都是通过V8自己的方式来进行分配和管理的。V8做这种限制的原因在于两点，其一，v8最初是设计给浏览器使用，浏览器上不大会遇到大内存的情况，所以限制值就足够使用了；其二，受限于V8的垃圾回收机制，按照官方说法，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的事件，在这样的时间花销下，应用的性能和响应能力都会直线下降。这就限制了开发者随心所欲使用大内存的想法。如果超过了这个限制，可能会导致进程退出。 v8的对象分配在V8中，所有JavaScript对象都是通过堆来进行分配的，可以通过1234567891011121314151617181920212223242526### V8的垃圾回收机制#### 内存分代在V8中，把内存分为新生代和老生代两种，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。从V8源码中可以看到，默认设置下，老生代内存在64位系统下为1400MB，在32位系统下为700MB。新生代内存由两个reserved_semispace_size_构成，reserved_semispace_size_在64位和32位系统下分别是16MB和8MB，所以新生代内存在64位和32位系统下分别为32MB和16MB。V8堆内存的最大保留空间公式为：4*reserved_semispace_size_ + max_old_generation_size_。所以准确的说v8堆内存在64位和32位系统下的大小为1464MB和732MB#### 内存回收算法##### Scavenge算法：空间换时间，适用于新生代内存采用Cheney算法，使用负值的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被赋值到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。（注意只复制存活的对象，由于新生代中对象生命周期比较短，所以这种算法有优异的表现）。在一定条件下，需要将存活周期长的对象移动到老生代中去（对象晋升），条件如下（满足一个即可） - 对象是否经历过Scavenge回收 - To空间的内存占用比例是否超过限制（25%）##### Mark-Sweep &amp; Mark—Compact：适用于老生代内存Mark-Sweep：标记清除，在标记阶段遍历堆中所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。（死对象在老生代中只占较小部分）Mark-Compact：标记整理，是为了解决Mark-Sweep算法清理之后内存不连续的情况，是在Mark-Sweep的基础上演变而来。差别在于对象在标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。要不断移动对象，执行速度不快。所以V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才会使用Mark-Compact。## 高效使用内存函数作用域释放后（函数执行完），作用域内的局部变量也会在下次垃圾回收中被释放。如果变量是全局变量（不通过var声明或定义在global变量上），由于全局作用域需要等到进程退出才能释放此时将导致引用的对象常驻内存（老生代中），如果需要释放常驻内存的对象，可以通过delete操作来删除引用关系。或者将变量重新复制，让旧对象脱离引用关系，在接下来的老生代内存清除和整理的过程中会被回收释放。```javascriptglobal.foo = &apos;an object&apos;delete global.foo//或者重新赋值global.foo = undefined//or null 一般来说在V8中通过重新赋值的方式解除引用比较好一点，因为通过delete删除对象属性有可能干扰V8的优化。需要注意的是闭包导致原始作用域不能得到释放而导致内存占用不会得到释放。 内存指标查看进程的内存占用：process.memoryUsage()rss(resident set size):进程的常驻内存heapTotal:堆中总共申请的内存量heapUsed：目前堆中使用中的内存量（字节） 查看系统的内存占用 os.totalmem()：返回操作系统的总内存 os.freemem()：返回操作系统的闲置内存堆外内存可以通过process.memoryUsage()可以看到堆中的内存用量总是小鱼进程的常驻内存用量，这意味着Node中的内存使用并非都是通过V8进行分配的。将那些不是通过V8分配的内存称为堆外内存。比如Buffer对象就不经过V8的内存分配机制，所以它不会有堆内存的大小限制 大内存应用在Node中不可避免的会存在操作大文件的情况，但是由于Node的内存限制，操作大文件要格外注意。不过Node提供了stream模块用于处理文件。stream是Node原生模块，直接应用即可。由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接来进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法可以通过流的方式对大文件进行操作。","categories":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/categories/Node/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://amazinglynch.com/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/tags/Node/"}]},{"title":"你真的了解JavaScript中的异步吗","slug":"你真的了解JavaScript中的异步吗","date":"2017-11-22T09:06:25.000Z","updated":"2017-11-23T14:42:13.650Z","comments":true,"path":"2017/11/22/你真的了解JavaScript中的异步吗/","link":"","permalink":"http://amazinglynch.com/2017/11/22/你真的了解JavaScript中的异步吗/","excerpt":"异步初探setTimeout和setInterval如果把setInterval的事时间设置为0，cpu就会频繁运行吗？答案是否定的，实验证明，浏览器上大约200次/秒，Node环境下，大约为1000次/秒。然而，如果是while循环的话，浏览器上大约触发频率是400万次/秒，Node环境下会达到400万次/秒。这是因为HTML规范推行的时延/间隔最小值是4毫秒。另外需要注意的是setTimeout和setInterval异步执行也会导致其定时精度不高。","text":"异步初探setTimeout和setInterval如果把setInterval的事时间设置为0，cpu就会频繁运行吗？答案是否定的，实验证明，浏览器上大约200次/秒，Node环境下，大约为1000次/秒。然而，如果是while循环的话，浏览器上大约触发频率是400万次/秒，Node环境下会达到400万次/秒。这是因为HTML规范推行的时延/间隔最小值是4毫秒。另外需要注意的是setTimeout和setInterval异步执行也会导致其定时精度不高。123456var start = new DatesetTimeout(function()&#123; var end = new Date console.log(end - start)&#125;,500)while(new Date - start &lt; 1000)&#123;&#125; 上诉代码原本想要500毫秒之后执行函数的，然而由于setTimout和setInterval的异步特性，需要等到JavaScript代码执行完之后才能执行，所以这里会在while循环出卡住1000毫秒 由于setTimeout和setInterval的不精确性，更高精度的计时方案是 process.nextTick() requestAnimationFrame():60帧/秒 和异步一起谈到的是非阻塞。非阻塞强调了Node的高速度。举个例子，异步MySql数据库驱动程序做一个查询可能要一个小时，但是负责发送查询请求的那个函数却能以微秒级速度返回。这对于那些需要快速处理海量需求的场景来说就很棒。 事件PubSub模式1234567891011121314PubSub = &#123;handlers:&#123;&#125;&#125;PubSub.on = function(eventType, handler) &#123; if(!(eventType in this.handlers)) &#123; this.handlers[eventType] = 1 &#125; this.handlers[eventType].push(handler)&#125;PubSub.emit = function(eventType) &#123; var handlerArgs = Array.prototype.slice.call(argument,1) for(var i = 0; i &lt; this.handlers[eventType].length; i++) &#123; this.handlers[eventType][i].apply(this,handlerArgs) &#125;&#125; Promise/Deferred对象 jQuery中的Promise/Deferred:Promise接收三种回调形式：done、fail、和progress。执行Promise对象时，运行的是done回调；拒绝Promise对象时，运行的是fail回调；对处于挂起状态的Deferred对象调用notify时，运行的是progress回调。1234567891011121314151617var nanowrimoing = $.Deferred();var wordGoal = 5000;nanowrimoing.progress(function(wordCount) &#123; var percentComplete = Math.floor(wordCount / wordGoal * 100) $('#indicator').text(percentComplete + '% complete')&#125;)nanowrimoing.done(function() &#123; $('#indicator').text('Good job!')&#125;)//对数字变化进行响应$('document').on('keypress',function() &#123; var wordCount = $(this).val().split(/s+/).length if(wordCount &gt;= wordGoal) &#123; nanowrimoing.resolve() &#125; nanowrimoing.notify(wordCount)&#125;) 准确的说，Deferred是Promise的超集，他比Promise多了一项关键特性：它可以直接使用resolve（执行）和reject（拒绝）来直接触发Deferred对象。纯Promise实例只允许添加多个调用，而且必须由其他什么东西来触发这些调用。 可以通过Deferred对象的promise()方法来生成一个Promise对象，需要注意的是生成的Promise对象只是原Deferred对象一个没有方法的副本。回调绑定在Deferred或者其下辖的Promise对象并无区别。每个Deferred对象都含有一个Promise对象，而每个Promise对象都代表一个Deferred对象。有了Deferred对象，就可以控制其状态，而有了纯Promise对象那个，只能读取其状态及附加回调。12var prompDeferred = new $.Deferred()var prompPromise = prompDeferred.promise() 理想情况下，所有的异步操作都应该返回Promise对象，但是大多数JavaScript API（浏览器或者Node)都是基于回调函数，而不是Promise对象。在基于回调函数的API中使用Promise对象最直接的方法就是生成一个Deferred对象并传递其触发器函数作为API的回调函数。12345678var fileReading = new $.Deferred()fs.readFile(filename,'utf8',function(err) &#123; if(err) &#123; fileReading.reject(err) &#125; else &#123; fileReading.resolve(Array.prototype.slice.call(arguments,1)) &#125;&#125;) worker对象的多线程多线程技术会有状态共享的难题，但是多线程又能充分利用多颗CPU内核。可以将worker理解为：应用程序的主线程对worker说，去，开一个单独的线程来运行这段代码。worker可以给主线程发送消息（反之亦可），其表现形式是事件队列中运行的回调。简而言之，与不同线程进行交互的方式在于JavaScript中进行I/O操作一模一样。 在操作系统层面：线程和进程有着巨大的区别，同一个进程内的多个线程可以分享状态，而彼此独立的进程之间则不能。 网页版的worker对象（HTML5）12345678910111213//主脚本var worder = new Worker('boknows.js')worker.addEventListener('message',function(e) &#123; console.log(e.data)&#125;)//向worker发送数据worker.postMessage('football')//boknows.jsself.addEventListener('message',function(e) &#123; //向主线程发送数据 self.postMessage(e.data)&#125;) 网页版的worker目标是在不损害DOM响应能力的前提下处理复杂的计算。可以用在解码视频，加密通信，解析网页式编辑器中的文本。通常情况下，worker对象会把自己的计算结果发送给主线程，由主线程去更新页面，为什么不直接更新页面呢？这里主要是为了保护JavaScript异步抽象概念。如果worker对象可以改变页面的标记语言，那么最终下场就会和java一样–必须将DOM操控代码封装成互斥量和信号量来避免竞态条件。 Node版的worker：clusterNode版的worker对象有cluster.fork()把运行自己的同一个脚本再次加载成一个独立的进程（可以通过cluster.isMaster来检测自己是主进程还是worker对象）,目的在于Node服务器要留出计算资源以保障其主要任务：处理请求。网页版本worker对象会加载一个独立的脚本。123456789101112131415var cluster = require('cluster')if(cluster.isMaster) &#123; //分化出worker对象 var coreCount = require('os').cpus().length for(var i = 0; i &lt; coreCount; i++) &#123; cluster.fork() &#125; //绑定death事件 cluster.on('death',function(worker) &#123; console.log('Worker' + worker.pid + 'has died') &#125;)&#125; else &#123; //立即死去 process.exit()&#125; 异步脚本加载script标签 放在head里：如果在head标签里放了大脚本会滞压所有页面的渲染工作，使得用户在脚本加载完毕之前一直处于‘白屏死机‘状态。、 放在body标签末尾：如果放的是大脚本，会让用户看到毫无生命力的静态页面，原本应该进行客户端渲染的地方却散步者不起作用的空间和空空如也的方框。另外就算不是大教本，这种方式使得浏览器在加载完整个文档之前无法加载这些脚本，这对于那些通过慢速连接传送的大型文档来说是一个瓶颈。 所以这里要对不同性质的脚本分而治之，那些负责让页面更好看，更好用的脚本应该立即加载，而那些可以待会再加载的脚本可以稍后再加载（async/defer） 脚本的三种加载方式同步加载（阻塞型）脚本的获取和执行是同步的。在此过程中个页面被阻塞，停止解析。但这样如果js中有输出document内容、修改dom、重定向等行为，就会造成页面堵塞。所以一般建议把标签放在结尾处，这样尽可能减少页面阻塞。 延迟加载（defer）脚本的获取是异步的，执行时同步的。脚本加载不阻塞页面解析，脚本在获取完之后并不立即执行，而是等到DOMready之后才开始执行。延迟加载就是为了解决这个问题，将JS切分成许多模块，页面初始化时只加载需要立即执行的JS，然后其它JS的加载延迟到第一次需要用到的时候再加载，类似图片的延迟加载。 异步脚本（async）脚本的获取是异步的，执行是同步的。和defer的不同点在于脚本获取之后会立即执行，这就会造成脚本的执行顺序和页面上脚本的排放顺序不一样，可能会造成脚本依赖问题","categories":[{"name":"JavaSctipt","slug":"JavaSctipt","permalink":"http://amazinglynch.com/categories/JavaSctipt/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://amazinglynch.com/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"http://amazinglynch.com/tags/异步/"}]},{"title":"异步编程","slug":"异步编程","date":"2017-11-18T08:11:41.000Z","updated":"2017-11-22T07:49:27.801Z","comments":true,"path":"2017/11/18/异步编程/","link":"","permalink":"http://amazinglynch.com/2017/11/18/异步编程/","excerpt":"函数式编程 高阶函数：JavaScript中函数式一等公民，可以作为参数传递，或者作为返回值返回 偏函数：指创建一个调用另一个部分-参数或变量已经预置的函数-的函数的用法","text":"函数式编程 高阶函数：JavaScript中函数式一等公民，可以作为参数传递，或者作为返回值返回 偏函数：指创建一个调用另一个部分-参数或变量已经预置的函数-的函数的用法 12345var isType = function(type) &#123; return function(obj) &#123; return Object.prototype.toString.call(obj) === ['Object' + type] &#125;&#125; 由上诉代码可知，这种通过指定部分参数来产生一个新的定制函数的形式就是偏函数。这样就不用挨个去实现isFunction()、isString()这样的函数，只需要在isType函数传入参数即可得到定制函数 异步编程的优势和难点优势利用事件循环的方式，JavaScript线程像一个分配任务和处理结果的大管家，I/O线程池里的各个I/O线程都是小二，负责兢兢业业地完成分配来的工作，小二与管家互不依赖，所以可以保持整体的高效率。这个模型的缺点在于管家无法承担过多的细节性任务，如果承担过多，则会影响到任务的分配和调度，管家忙个不停，小二却没有活干，这样效率就会降低。Node是为了解决编程模型中阻塞I/O的性能问题的，采用了单线程模型，这导致Node更新一个处理I/O密集问题的能手，cpu密集型则取决于管家能耐。由于海量请求同时作用在单线程上，需要防止任何计算耗费过多的cpu时间片。所以无论是I/O密集型还是计算密集型，只要计算不影响异步I/O的调度，都不会有问题。所以可以将海量计算分解为诸多小量计算，通过setImmediate()进行调度。 难点 异常处理:不能像同步代码那样使用try…catch，因为异步I/O分为两步，提交请求，和处理结果。try…catch只能捕获提交请求这个阶段的错误（只能捕捉当前这个事件循环的错误），因为处理结果（回调函数的执行）是在下一个事件循环才会执行，try…catch捕捉不到callback执行时抛出的异常。 在Node中，我们在处理异常时形成了一种规定，会将异常放在回调的一个实参传递，如果不为空，则说明有异常。 函数嵌套过深：多个异步调用 多线程编程：单线程无法高效利用多核cpu的服务器，因为单个Node进程实质上没有充分利用多核cpu。web workers。 异步编程解决方案事件发布/订阅模式依赖于Node自身提供的event模块，回调函数事件化。Node对事件的发布订阅机制做了一些小的限制。比如说对一个事件添加的侦听器不能超过10个（这个限制也可以自己修改）为了防止内存泄漏以及过多占用cpu Promise/Deferred模式这种模式可以先执行异步调用，延迟传递处理函数。这种方式比预先传入回调更好看一些。在原始API里一个事件只能处理一个回调，而通过deferred对象，可以对事件加入任意的业务处理逻辑。CommonJS的Promise/A就是这种模式的一种实现。 1234$.get('/api) .success(onSuccess) .error(onErroe) .complete(onComplete) 流程控制async async.series()：异步的串行执行 async.parallel()：异步的并行执行 async.waterfall()：异步调用的依赖处理","categories":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/categories/Node/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://amazinglynch.com/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/tags/Node/"}]},{"title":"NodeJS异步IO","slug":"NodeJS异步IO","date":"2017-11-17T03:37:16.000Z","updated":"2017-11-17T14:33:28.899Z","comments":true,"path":"2017/11/17/NodeJS异步IO/","link":"","permalink":"http://amazinglynch.com/2017/11/17/NodeJS异步IO/","excerpt":"提到Node，我们很容易想到异步IO，但是什么是异步IO？为什么要用异步IO？异步IO执行流程是怎么样的？你真的了解Node中的异步IO吗？","text":"提到Node，我们很容易想到异步IO，但是什么是异步IO？为什么要用异步IO？异步IO执行流程是怎么样的？你真的了解Node中的异步IO吗？ 导读异步IO其实并不是一个新鲜的概念，它早就存在于操作系统中，但是由于使用异步的编程模式不太好理解，以至于一些高级语言典型如PHP，在语言层面屏蔽了异步甚至是多线程，PHP是以同步阻塞的方式来运行的，这种设计的优点在于，程序员同步编写代码，代码很好理解。缺点在于阻塞导致其不能很好的并发。Node的设计理念是事件驱动，异步I/O。 为什么需要异步I/O用户体验首先我们要知道的是浏览器中的JavaScript是在单线程上执行，而且它还是与UI渲染共用一个线程。这就意味着JavaScript在执行过程的时候UI渲染和响应处于停滞状态（所以脚本执行时间不能过长）。需要注意的是B/S模型总，网络速度会给用户体验带来很大麻烦。如果以同步方式获取服务器上的资源，JavaScript会停住等待，这期间UI会停顿，交互不能响应。 同步和异步运行时间比较1234567//同步方式运行，总共耗时M+NgetDate(url1) //耗时MgetDate(url2) //耗时N//异步方式运行，总共耗时max(M,N)getDate(url1,function(result) &#123;&#125;)//耗时MgetDate(url2,function(result) &#123;&#125;)//耗时N 资源分配 需要了解的是，如果有一组互不相关的任务需要完成，主流的方法有两个，单线程串行执行和多线程并行的区别。多线程的代价在于执行期线程上下文切换开销比较大。在业务复杂的时候，还经常面临锁，状态同步的问题。有点在于在多核cpu上能够有效提升cpu利用率。单线程优点在于编程方式比较符合人的思维习惯，易于表达。缺点在于其性能不是很好，一个略慢的任务会导致后续执行代码被阻塞。在计算机资源中，通常I/O与CPU计算之间是可以并行进行的。但是同步编程却使得I/O操作让后续任务等待，造成资源不能很好的利用。 Node在单线程同步和多线程并行之间选择的方案是：利用单线程，远离死锁，状态同步的问题，利用异步，远离单线程阻塞的问题，更好利用cpu。 另外Node为了弥补单线程无法利用多核CPU的缺点，也提供了类似前端web workers的子进程。该子进程可以通过工作进程高效利用CPU和I/O。 异步I/O与非阻塞I/O异步I/O ≠ 非阻塞I/O同步/异步和阻塞/非阻塞是两回事。对操作系统内核I/O来说，只有阻塞I/O和非阻塞I/O。 阻塞I/O：调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。以读文件为例，磁盘寻道，读取数据，复制数据到内存中，调用结束 非阻塞I/O：调用之后立即返回，返回的不是业务层期望的数据，而是当前调用的状态，如果要获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。（重复确认-&gt;轮询），其麻烦的地方在于需要采用轮询技术去确认是否完成数据获取。cpu判断，耗费cpu资源。轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于应用程序来说，这只能算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧会需要很多时间来等待。理想情况下的非阻塞异步I/O应该是应用程序发起非阻塞调用，无需通过遍历或者时间唤醒等待方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或者回调将数据传递给应用程序即可。 现实的异步I/O通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让另一个线程进行计算处理，通过线程之间的通信将I/O得到得数据进行传递，这种便是典型的线程池模拟异步I/O。典型的*nix下的libeio和windows下的IOCP都是使用这种方式，而Node提供了libuv作为抽象封装层，使得Node支持跨平台异步I/O。 需要注意的是，我们常说Node是单线程的，指的是JavaScript执行在单线程中，在Node中，无论在什么平台，内部完成I/O任务都另有线程池。除了用户代码无法并行执行外，所有的I/O则是可以并行起来的 Node中的异步I/O事件循环（event loop）整个Node执行都在一个事件循环中 观察者在每个循环中，怎么判断是否有事件需要处理呢？这里就要引入观察者了。每个事件循环中都有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。事件循环是一个典型的生产者/消费者模型，异步IO，网络请求等是事件的生产者，源源不断的为Node提供不同类型的事件，这些事件被传递到观察者那里，事件循环则从观察者那里取出事件并处理。 请求对象对于Node中的异步IO调用而言，回调函数不由开发者来调用，从JS发起调用到IO操作完成，存在一个中间产物，叫请求对象。在JS发起调用后，JS调用Node的核心模块，核心模块调用C++内建模块，內建模块通过libuv判断平台并进行系统调用。在进行系统调用时，从JS层传入的方法和参数都被封装在一个请求对象中，请求对象被放在线程池中等待执行。JS立即返回继续下面的操作。 执行回调在线程可用时，线程会取出请求对象来执行IO操作，执行完后将结果放在请求对象中，并归还线程。在事件循环中，IO观察者会不断的找到线程池中已经完成的请求对象，从中取出回调函数和数据并执行 Node中一些非I/O的异步API定时器setTimeout(),setInterval()不需要I/O线程池的作用，创建的定时器对象会被插入到观察者内部的一个红黑树中，每次Tick(一次 循环)执行时，会从该红黑树中迭代取出定时器对象，检查是否超时，如果超过，就形成一个事件，回调函数将立即执行。定时器的问题在于不精确，如果某一次循环占用的时间较多，那么下次循环时，可能就超出时间了。 process.nextTick()将回调函数放入队列中，在下一轮Tick时取出执行。与setTimeout(fn,0)相比，nextTick更加轻量高效，而且定时器精度也不高。 setImmediate()和process.nextTick()很类似。process.nextTick()中的回调函数优先级要高于setImmediate(),原因是事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check对象。在每一轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。具体实现上，process.nextTick()的回调函数保存在一个数组（每轮循环会将数组中的回调函数全部执行完）中，而setimmediate()结果则是保存在链表（在每轮循环中执行链表中的一个回调函数）中。 事件驱动的高性能服务器几种经典服务器模型 同步式：一次只能处理一个请求，其余请求都处于等待状态 每进程/每请求：可以处理多个请求，但是不具备扩展性，因为系统资源有限 每线程/每请求：线程比进程轻量，每个线程都占用一定的内存，大并发，内存仍会用完。（Apacher） 事件驱动的服务器Node和nginx都采用这种事件驱动的服务器。无须为每个请求创建一个额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换代价低，从而实现高性能。","categories":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/categories/Node/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://amazinglynch.com/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/tags/Node/"}]},{"title":"NodeJS模块机制","slug":"NodeJS模块机制","date":"2017-11-16T14:13:32.000Z","updated":"2017-11-17T03:08:20.574Z","comments":true,"path":"2017/11/16/NodeJS模块机制/","link":"","permalink":"http://amazinglynch.com/2017/11/16/NodeJS模块机制/","excerpt":"CommonJS规范出发点JavaScript存在缺陷，导致在后端其无法用来开发大型应用","text":"CommonJS规范出发点JavaScript存在缺陷，导致在后端其无法用来开发大型应用 没有模块系统 标准库少。文件操作，I/O流都没有标准API 没有标准接口。与web服务器或者数据库的接口 缺乏包管理 具体规范 模块引用 require 模块定义 需要注意的是，上下文提供exports对象用于导出当前模块的方法和变量，并且它是唯一导出的出口。而在模块中还存在一个module对象，它代表模块自身，exports是module的属性。在Node中，一个文件就是一个模块，可以将方法挂载在exports对象上作为属性即可定义导出的方式。 模块标识模块标识就是require()方法的参数，必须是符合小驼峰命名的字符串，或者以 .、..开头的相对路径。可以没有文件后缀.js Node实现引入模块的三个步骤 路径分析 文件定位 编译执行不同类别模块加载的区别 核心模块(Node提供)：在Node源代码编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块直接被加载进内存中(没有文件定位和编译执行的过程)，加载速度很快 文件模块(用户编写)：在运行时动态加载，需要历经路径分析，文件定位，编译执行过程，比核心模块慢一些 路径分析. 核心模块：优先级仅次于缓存加载，被编译成二进制. 路径形式的文件模块(相对定位OR绝对定位)：当成文件模块来处理。转化成真实路径，并且将编译执行后的结果放入缓存中. 自定义模块 自定义模块指的是非核心模块，同时也不是路径形式的标识符。可以认为是一种特殊的文件模块，可能是一个文件或者包的形式，查找比较费时。 查找策略 当前目录下的node_modules 父目录下的node_modules 沿路径向上递归，知道根目录下的node_modules 文件定位扩展名分析标识符不包含文件名，Node会按照.js、.node、.json的次序补足，依次尝试 目录分析和包分析完加扩展名的标识符后，可能还没有找到对应文件，但可以得到一个目录。Node会自动将该目录当做一个包来处理。Node（CommonJS规范）首先会在当前目录下找到package.json文件，找到main字段，对该文件名进行定位。如果没有找到，则会将index作为默认文件名，依次查找index.js、index.node、index.json。如果还没有找到则进入下一个模块路径进行同样方式的查找 模块编译Node中每个文件模块都是一个对象。构造函数定义如下1234567891011function Module(id,parent) &#123; this.id = id; this.export = &#123;&#125;; this.parent = parent; if(parent &amp;&amp; parent.children) &#123; parent.children.push(this) &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 不同类型的文件（扩展名不一样），Node会采用不同的读取方式 模块的载入（模块的读取） .js文件。通过fs模块同步读取文件 .node文件。用c/c++编写的扩展文件，通过dlopen()方法加载最后编译生成文件 .json文件。通过fs模块同步读取后，用JSON.parse()解析并且返回结果 其他类型 。按照js文件方法载入 JavaScript模块的编译Node会对获取的JavaScript文件进行头尾包装123456(function(exports,require,module,__filename,__dirname) &#123; var math = require('math') exports.add = function() &#123; &#125;&#125;); 然后通过vm原生模块的runInThisContenxt()方法执行（类似eval，但是有明确上下文，不污染全局环境），返回一个function对象，最后将当前模块对象的exports，require…等参数传入这个function()执行。执行之后，模块的exports属性会返回给调用方 这也是为什么这些变量没有定义在模块文件，却可以使用的原因。同时需要注意的是这里的module.exports 和 exports之间的关系。在模块内部是不能直接将值赋给exports对象，因为exports对象是通过形参的方式传入函数的，直接赋值会改变形参的引用，但并不能改变作用域外的值。所以应该将值以属性的方式赋进去，或者直接赋值给module.exports对象 c/c++模块编译Node会调用process.dlopen()方法进行加载和执行。Node架构下，dlopen()方法在windows和Linux平台下分别有不同实现。通过libuv兼容层进行了封装 JSON文件的编译通过JSON.parse()把通过fs模块异步读取的内容传入，即可得到对象，然后将对象赋给模块对象的exports，以供外部使用。一般对于配置文件，可以直接require(),无需fs读取。 包和NPMCommonJS规范定义的包结构 package.json：包描述文件 bin ：存放可执行二进制文件 lib：存放JS代码 doc：存放文档 test：存放单元测试代码 CommonJS和NPM的包描述文件 需要注意的是，CommonJS规范的package.json字段和NPM所实现的package.json字段略微有些差别。NPM在CommonJS的基础上添加了一些字段 几个字段解释 bin：一些包作者希望包可以作为命令行工具使用，配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行 main：模板引入方法require()在引入包时，会有限检查这个字段，并将其作为包中其余模块的入口 devDependencies：一些模块只在开发时需要依赖 engine：支持的JavaScript引擎列表，ejs，ppc，mips，jsc，node，v8等 NPM常用功能 安装依赖包：npm install 全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以在任何地方通过require()都能引用到它。实际上，全局安装时将一个包安装为全局可用的可执行命令，它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同路径下（全局模式安装的所有模块宝都被安装进了一个统一的目录下，这个目录是path.resolve(process,execPath,&#39;..&#39;,&#39;..&#39;,&#39;lib&#39;,&#39;node_modules&#39;)这里process.execPath是node的安装目录，由于环境变量的作用，在任何目录下执行node命令都会链接到node安装目录） 查看可用包：npm ls 分析出当前路径通过模块路径找到的所有包，并生成依赖树 NPM的问题每个人都可以向npm仓库发布包，导致包的质量良莠不齐，一个可靠的，优秀的包必须有良好的测试，良好的文档，良好的测试覆盖率，良好的编码规范等等","categories":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/categories/Node/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://amazinglynch.com/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/tags/Node/"}]},{"title":"为Hexo + Yilia的博客上添加livere(来必利)作为评论支持","slug":"为Hexo-Yilia的博客上添加livere-来必利-作为评论支持","date":"2017-07-23T08:06:02.000Z","updated":"2017-11-16T15:11:48.601Z","comments":true,"path":"2017/07/23/为Hexo-Yilia的博客上添加livere-来必利-作为评论支持/","link":"","permalink":"http://amazinglynch.com/2017/07/23/为Hexo-Yilia的博客上添加livere-来必利-作为评论支持/","excerpt":"在搭建好博客之后，总感觉少了点什么，看了看别人的博客，恍然大悟，没有评论的博客哪能叫博客啊，要是别人发现你的博客有错，都没法联系你。于是就开始琢磨给博客添加评论。 由于我之前选用的是Yilia，在这个主题中提供了几种参考的评论系统（网易云跟帖，多说，disqus，畅言），本着学习 + 实践的态度。我开始了试错之路。","text":"在搭建好博客之后，总感觉少了点什么，看了看别人的博客，恍然大悟，没有评论的博客哪能叫博客啊，要是别人发现你的博客有错，都没法联系你。于是就开始琢磨给博客添加评论。 由于我之前选用的是Yilia，在这个主题中提供了几种参考的评论系统（网易云跟帖，多说，disqus，畅言），本着学习 + 实践的态度。我开始了试错之路。 多说 以前用的比较多，不过现在关了。网易云跟帖 不多说了Disqus 这个在国外用的比较多，也是当之无愧的行业老大，但是它被墙了，没有梯子用不了，所以放弃。畅言 畅言是搜狐旗下额产品，功能还是挺不错，但是样式就各有各的看法咯！另外要注意一点的是，使用畅言必须要备案，不备案的话是用不了的。由于我使用的是git page，属于二级域名，自然也就用不了畅言了。如果你买了域名，同时也备案了，我觉得可是试一试。友言 样式还是比较好看的，不过要注意的是友言使用的是HTTP协议，如果你的博客使用的是HTTPS协议(git page就是如此)的话，也是用不了的(HTTP请求会被浏览器禁掉)，这里要特别注意。（livere）来比力 来自韩国的产品，UI比较现代化吧感觉。支持QQ，微信，微博，GitHub等多种登录方式，不需要备案，使用HTTPS协议，因此我选用它来作为我的评论模块。以下是介绍在Hexo + Yilia主题的博客中使用livere。livere使用方法注册livere 登录liver官网 填写相关信息 livere提供两个版本 City版：一款适合所有人使用的免费版本 Premium版：一款能够帮助企业实现自动化管理的多功能收费版本 在管理页面-&gt;代码管理-&gt;一般网站，复制那一段代码到粘贴板 在博客中配置插件 打开 根目录\\themes\\yilia_config.yml，然后在里面添加一项 1livere: true 注意:后面有一个空格 在根目录\\themes\\yilia\\layout_partial\\post目录下添加一个livere.ejs文件写入之前在liver后台生成的那一段代码 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;your data-uid&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; （其实这一段也就是在之前步骤里的管理页面-&gt;代码管理-&gt;一般网站那一段代码） 打开位于在博客根目录\\themes\\yilia\\layout_partial目录下的artical.ejs。找到判断主题的那个地方（在&lt;% if (!index &amp;&amp; post.comments){ %&gt;后），添加如下代码 1234567&lt;% if (theme.livere)&#123; %&gt; &lt;%- partial(&apos;post/livere&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt; 进行到这一步，插件的配置也就结束了 重新构建博客在博客根目录下执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。重新构建网站，然后等一会，你就可以看到效果了。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://amazinglynch.com/tags/博客搭建/"}]},{"title":"我的个人博客终于搭建好了···（撒花）","slug":"我的个人博客终于搭建好了···（撒花）","date":"2017-07-17T08:35:00.000Z","updated":"2017-07-23T12:15:27.477Z","comments":true,"path":"2017/07/17/我的个人博客终于搭建好了···（撒花）/","link":"","permalink":"http://amazinglynch.com/2017/07/17/我的个人博客终于搭建好了···（撒花）/","excerpt":"","text":"欢迎进入我的个人博客。","categories":[],"tags":[]}]}