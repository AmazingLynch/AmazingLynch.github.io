{"meta":{"title":"colgin's Blogs","subtitle":"记录生活与学习的点点滴滴","description":"个人博客","author":"colginh","url":"http://colgin.com"},"pages":[{"title":"categories","date":"2017-11-16T14:55:09.000Z","updated":"2017-11-16T14:56:28.000Z","comments":false,"path":"categories/index.html","permalink":"http://colgin.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-16T14:45:52.000Z","updated":"2017-11-16T14:55:52.000Z","comments":false,"path":"tags/index.html","permalink":"http://colgin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue中的scope slot和render函数","slug":"scope-slots-and-render-in-vue","date":"2020-07-05T01:49:48.000Z","updated":"2020-07-05T02:51:07.272Z","comments":true,"path":"2020/07/05/scope-slots-and-render-in-vue/","link":"","permalink":"http://colgin.com/2020/07/05/scope-slots-and-render-in-vue/","excerpt":"在Vue中使用slot-scope和render函数都可以做到自定义渲染，其实二者有很多相通之处，本文将通过几个例子来分析slot-scope和render 的灵活应用。","text":"在Vue中使用slot-scope和render函数都可以做到自定义渲染，其实二者有很多相通之处，本文将通过几个例子来分析slot-scope和render 的灵活应用。 代码背景本文一个需要实现自定义表格，每列的内容都希望可以自定义渲染，在业务组件business.vue中通过column传给给Grid组件一些配置，然后就可以实现自定义渲染。 为了文章篇幅，本文代码均为精简代码，只是为了演示最核心的部分。 实现方案render 函数1234567891011121314151617181920// Render.jsexport default &#123; functional: true, props: &#123; row: Object, column: Object, rowIndx: Number, columnIndx: Number, render: Function &#125;, render(h, ctx) &#123; const params = &#123; row: ctx.props.row, column: ctx.props.column, rowIndex: ctx.props.rowIndex, columnIndex: ctx.props.columnIndx &#125; return ctx.props.render(h, params) &#125;&#125; table组件columns prop中可以接收render函数，将rende函数r传递给render组件。 1234567891011121314&lt;!-- Grid.vue --&gt;&lt;template&gt;&lt;div&gt; &lt;tbody&gt; &lt;tr v-for=\"(row, rowIndex) in data\"&gt; &lt;td v-for=\"(col, colIndex) in columns\"&gt; &lt;template v-if=\"'render' in col\"&gt; &lt;Render :render=\"col.render\" :row=\"row\" :column=\"col\" :rowIndex=\"rowIndex\" :columnIndex=\"colIndex\" /&gt; &lt;/template&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/div&gt;&lt;/template&gt; 在使用的时候配置render项 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;Grid :column=\"columns\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return [ &#123; title: 'name', render(h, &#123; row, column, rowIndex, columnIndex&#125;) =&gt; h('span', `$&#123;rowIndex&#125;: $&#123;row.name&#125;`) &#125; ] &#125;&#125;&lt;/script&gt; slot-scope在组件内支持配置slot，如果slot有值的话，则使用slot渲染 1234567891011121314&lt;!-- Grid.vue --&gt;&lt;template&gt;&lt;div&gt; &lt;tbody&gt; &lt;tr v-for=\"(row, rowIndex) in data\"&gt; &lt;td v-for=\"(col, colIndex) in columns\"&gt; &lt;template v-if=\"'slot' in col\"&gt; &lt;slot :name=\"col.slot\" :row=\"row\" :column=\"col\" :rowIndex=\"rowIndex\" :columnIndex=\"colIndex\" /&gt; &lt;/template&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/div&gt;&lt;/template&gt; 在使用Grid组件的时候，通过slot选项实现自定义渲染 1234567891011121314151617181920212223242526272829303132333435&lt;!-- business.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;Grid :colomn=\"columns\"&gt; &lt;template v-slot:name=\"&#123; row &#125;\"&gt; &lt;input type=\"text\" v-model=\"editName\" /&gt; &lt;span v-else&gt;&#123;&#123; row.name &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;template v-slot:age=\"&#123; row &#125;\"&gt; &lt;input type=\"text\" v-model=\"editAge\" /&gt; &lt;span v-else&gt;&#123;&#123; row.age &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/Grid&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; columns: [ &#123; text: 'name', slot: 'name' &#125;, &#123; text: age, slot: 'age' &#125; ] &#125; &#125;&#125;&lt;/script&gt; slot -&gt; render 使用上转化有得时候Grid组件并不支持slot选项，仅仅支持render函数，但是我们又想通过scope-slot的方式来使用。 1234567891011121314&lt;!-- Grid.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;tbody&gt; &lt;tr v-for=\"(row, rowIndex) in data\"&gt; &lt;td v-for=\"(col, colIndex) in columns\"&gt; &lt;template v-if=\"'render' in col\"&gt; &lt;Render :render=\"col.render\" :row=\"row\" :column=\"col\" :rowIndex=\"rowIndex\" :columnIndex=\"colIndex\" /&gt; &lt;/template&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/div&gt;&lt;/template&gt; 可以通过将插槽转换为render函数来实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- business.vue --&gt;&lt;template&gt;&lt;div&gt; &lt;Grid :colomn=\"columns\" ref=\"grid\"&gt; &lt;template v-slot:name=\"&#123; row &#125;\"&gt; &lt;input type=\"text\" v-model=\"editName\" /&gt; &lt;span v-else&gt;&#123;&#123; row.name &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;template v-slot:age=\"&#123; row, index &#125;\"&gt; &lt;input type=\"text\" v-model=\"editAge\" /&gt; &lt;span v-else&gt;&#123;&#123; row.age &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/Grid&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; columns: [ &#123; text: 'name', render: (h, &#123; row, column, rowIndex, columnIndex&#125; ) =&gt; &#123; return this.$refs.grid.$scopeSlots.name(&#123; row, column, rowIndex. columnIndex &#125;) &#125; &#125;, &#123; text: 'age', render: (h, &#123; row, column, rowIndex, columnIndex&#125; ) =&gt; &#123; return this.$refs.grid.$scopeSlots.name(&#123; row, column, rowIndex. columnIndex &#125;) &#125; &#125; ] &#125; &#125;&#125;&lt;/script&gt; 这里将Grid组件的scope-slots通过组件实例的$scopeSlots选项取到（本质上是一个函数），然后在business中的render函数中返回调用结果，尽管Grid组件不支持插槽，但是我们在使用Grid的时候，可以在模板中写插槽（仅仅写是不会生效的），然后将插槽转化为render函数。 slot-&gt; render组件中转化其实，组件内部支持scope-slot不仅仅可以通过slot标签来实现，还可以用下面这种方式来实现 1234567891011121314// SlotRender.jsexport default &#123; functional: true, inject: ['Grid'], props: &#123; row: Object, column: Object &#125;, render: (h, ctx) =&gt; return h('div', ctx.injection.Grid.$scopeSlots[ctx.props.column.slot](&#123; row: ctx.props.row, column: ctx.props.column &#125;))&#125; 123456789101112131415161718192021222324&lt;!-- Grid.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;tbody&gt; &lt;tr v-for=\"(row, rowIndex) in data\"&gt; &lt;td v-for=\"(col, colIndex) in columns\"&gt; &lt;template v-if=\"'slot' in col\"&gt; &lt;SlotRender :row=\"row\" :column=\"col\" :rowIndex=\"rowIndex\" :columnIndex=\"colIndex\" /&gt; &lt;/template&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; provide() &#123; return &#123; Grid: this &#125; &#125;&#125;&lt;/script&gt; 在使用上，仍然可以通过插槽 1234567891011121314151617181920212223242526272829303132333435&lt;!-- business.vue --&gt;&lt;&lt;template&gt;&lt;div&gt; &lt;Grid :colomn=\"columns\" ref=\"grid\"&gt; &lt;template v-slot:name=\"&#123; row &#125;\"&gt; &lt;input type=\"text\" v-model=\"editName\" /&gt; &lt;span v-else&gt;&#123;&#123; row.name &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;template v-slot:age=\"&#123; row &#125;\"&gt; &lt;input type=\"text\" v-model=\"editAge\" /&gt; &lt;span v-else&gt;&#123;&#123; row.age &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/Grid&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; columns: [ &#123; text: 'name', slot: 'name' &#125;, &#123; text: 'age', slot: 'age' &#125; ] &#125; &#125;&#125;&lt;/script&gt; 这里要注意的是，$scopeSlots只能在组件实例上能够取到，所以上面的两个例子中，在上层组件获取Grid实例的方式是通过ref的方式，在Grid子组件中获取Grid实例的方式是通过provide/inject。 以上就是scopeSlots 和 render函数，其实最主要的是render函数和slot方式，另外两种方式能够更好地帮助你理解作用域插槽和render函数。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://colgin.com/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://colgin.com/tags/Vue/"}]},{"title":"Vue中的key","slug":"key-in-vue","date":"2020-07-05T01:32:17.000Z","updated":"2020-07-05T02:51:43.689Z","comments":true,"path":"2020/07/05/key-in-vue/","link":"","permalink":"http://colgin.com/2020/07/05/key-in-vue/","excerpt":"不管是Vue，还是React，key都作为一个特殊属性，那么这个属性到底有什么用呢？本文以vue为例子分析key的作用以及自己的一些思考。","text":"不管是Vue，还是React，key都作为一个特殊属性，那么这个属性到底有什么用呢？本文以vue为例子分析key的作用以及自己的一些思考。 困境在一些博客中，经常会写到列表渲染要用key来区分不同列表项，而且最好不要用数组的索引作为key，因为这样会造成一些问题，推荐使用独一无二的id作为key，可以更加高效的渲染。 为什么key这个属性会有这些问题和讲究呢？如果违背了，会出现什么问题呢？ 初识在vue官网文档上说到，说到key是用在Vue的diff算法中，在新旧nodes对比时辨识vnodes，如果不实用key，vue会使用一种最大程度减少动态元素并且尽可能尝试就地修改/复用相同类型元素的算法。使用key时，会基于key的变化重新排列元素顺序。 这里有几个关键字，diff算法，对比辨识，就地复用/修改，基于key重排。在下面的深入部分将会讲到。 深入先看一下代码上下文 1234567891011121314151617181920212223242526272829303132333435&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;Child v-for=\"(user, index) in users\" :key=\"index\" :name=\"user.name\" @delete=\"del(index)\"/&gt; &lt;button @click=\"insert\"&gt;insert&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from \"./components/Child.vue\";export default &#123; name: \"App\", components: &#123; Child &#125;, data() &#123; return &#123; users: [ &#123; id: 1, name: \"one\" &#125;, &#123; id: 2, name: \"two\" &#125;, &#123; id: 3, name: \"three\" &#125; ] &#125;; &#125;, methods: &#123; del(index) &#123; this.users.splice(index, 1); &#125;, insert() &#123; this.users.splice(1, 1, &#123; id: 4, name: 'four' &#125;) &#125; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233&lt;!-- Child.vue --&gt;&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;span&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt; &lt;input type=\"text\" v-model=\"msg\"&gt; &lt;button @click=\"handleClick\"&gt;del&lt;/button&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;let i = 1;export default &#123; name: \"Child\", props: &#123; name: String &#125;, data() &#123; return &#123; msg: \"\", count: i++ &#125;; &#125;, methods: &#123; handleClick() &#123; this.$emit(\"delete\"); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 可以在codesandbox查看具体效果 之后的讨论只在上面的代码基础上修改Child组件上key的值。 首先将key绑定为下标索引值。渲染出来是没有毛病的，但是前面我们看到key作用的时间是在diff的时候，当数据发生变化的时候，vnode节点树就会重新生成，之后通过diff找到修改的地方，然后把修改的地方通过dom方法修改（diff算法可以看看vue源码或者snabbdom，二者都采用了双端比较的算法，此处不讨论过多细节），所以，可以先可以在input里输入一些文字，这些文字是存在组件内部state的，然后，点击第二个Chlld的删除，此时却发现，只有外部的info显示更新了，而input里面的文字竟然没有更新 这是为什么呢？让我们回想一下当点击删除的时候发生了什么。首先是数据更新，数据更新之后会触发重新生成vnode，然后进行diff，diff完之后会修改dom。这个diff过程就是key作用的地方，两次的vnode结果大概如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 前&#123; tag: 'div', props: &#123; id: 'app' &#125;, children: [ &#123; tag: 'Child', key: 0, name: 'one' &#125;, &#123; tag: 'Child', key: 1, name: 'two' &#125;, &#123; tag: 'Child', key: 2, name: 'three' &#125;, &#123; tag: 'button', children: 'insert' &#125; ]&#125;// 后&#123; tag: 'div', props: &#123; id: 'app' &#125;, children: [ &#123; tag: 'Child', key: 0, name: 'one' &#125;, &#123; tag: 'Child', key: 1, name: 'three' &#125;, &#123; tag: 'button', children: 'insert' &#125; ]&#125; 在贴一段diff的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; let oldStartIdx = 0 let newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by &lt;transition-group&gt; // to ensure removed elements stay in correct relative positions // during leaving transitions const canMove = !removeOnly if (process.env.NODE_ENV !== 'production') &#123; checkDuplicateKeys(newCh) &#125; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(oldCh, oldStartIdx, oldEndIdx) &#125; &#125; 这里的关键点在于sameVnode的实现，它决定了是复用元素还是根据vnode创建元素。 12345678910111213141516function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; 看到这里，应该可以知道，前后两次vnode的第二个Child节点，由于tag一样，key都是1，所以这里会复用原来的组件实例，然后调用patchVnode去更新，比如这里就是新vnode与旧版的vnode的name不一样，这些将会通过更新来实现。至于为什么input输入框里的内容没有变，原因是Child组件被复用了，input里的内容受到组件内部state的影响，既然组件没有被销毁，那么就说明了state没有被修改，这种情况的复用和修改一个组件的props效果是一样的，这也就是文档上所说的就地复用/修改。 其实还可以通过count来观察到组件是否是新建的实例，每新建一个实例count就会加1，而key为index，删除了第二条元素，发现最后面的count还是之前的2。这说明了这个Child实例就是之前三个user渲染出来的第二项。 如果key是user.id的话，删除任意一个元素，sameVnode由于key不相等，不会想之前那样简单复用了，而是根据key去找在旧的children里与当前key相等的元素进行复用，找不到就会创建新的实例，这种情况input 和 后面的count都准确渲染了 如果不传key，每次sameVnode中比较undefined === undefined都是成立的，复用也会出现前面说到的和使用索引作为key一样的问题。 按照上面的分析，可以很快的分析出插入时候的情况。插入是将第二个删除，插入第四个。 123insert() &#123; this.users.splice(1, 1, &#123; id: 4, name: 'four' &#125;)&#125; 使用索引作为key时， 使用user.id作为key时 可以看到这里count增加了，说明是创建了新的实例。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://colgin.com/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://colgin.com/tags/Vue/"}]},{"title":"package.json里的main字段","slug":"package-json里的main字段","date":"2020-06-06T16:10:03.000Z","updated":"2020-06-06T16:19:00.146Z","comments":true,"path":"2020/06/07/package-json里的main字段/","link":"","permalink":"http://colgin.com/2020/06/07/package-json里的main字段/","excerpt":"package.json是一个JavaScript的项目描述文件，其中main字段是非常重要的一个字段，它描述了程序的入口。本文将分析作为一个模块（不是应用）的main字段。","text":"package.json是一个JavaScript的项目描述文件，其中main字段是非常重要的一个字段，它描述了程序的入口。本文将分析作为一个模块（不是应用）的main字段。 main vs modulemain字段是程序的入口，在npm官网, then your main module’s exports object will be returned. This should be a module ID relative to the root of your package folder. For m)有这么一段描述 The main field is a module ID that is the primary entry point to your program. That is, if your package is named foo, and a user installs it, and then does require(&quot;foo&quot;), then your main module’s exports object will be returned This should be a module ID relative to the root of your package folder. main字段是commonJS规范的入口文件，对于客户端应用来说，如果使用webpack或者rollup这样的现代化打包器打包应用的话，其实优先考虑的是module字段，如果module字段没有值的话，才会使用main字段。具体看 pkg.module main的指向在看一些开源代码库的实现的时候，关于main字段有一些不一样的理解。 比如vuex中package.json是这样的 1234567891011121314&#123; ... \"main\": \"dist/vuex.common.js\", \"module\": \"dist/vuex.esm.js\", \"unpkg\": \"dist/vuex.js\", \"jsdelivr\": \"dist/vuex.js\", \"typings\": \"types/index.d.ts\" \"files\": [ \"dist\", \"types/index.d.ts\", \"types/helper.d.ts\", \"types/vue.d.ts\" ]&#125; 可以看到这里的main指向了一个使用rollup打包的开发版本的commonjs格式的打包后的文件。module指向的是一个使用rollup打包的开发版本的esm格式的包。其他诸如jsdelivr, unpkg使用的都是开发rollup打包的umd格式的包。vuex的dist目录会被推送到github，当包的使用中使用npm install安装包的时候，dist目录也会存在与node_modules/vuex目录下。 在另一个知名的包axios的package.json里就和vuex有些区别 123456789&#123; ... \"main\": \"index.js\", \"browser\": &#123; \"./lib/adapters/http.js\": \"./lib/adapters/xhr.js\" &#125;, \"jsdelivr\": \"dist/axios.min.js\", \"unpkg\": \"dist/axios/min.js\"&#125; 这package.json没files字段，说明安装的时候，项目的所有文件夹和根目录下非配置文件都会被安装进去，其实也就只有两个文件夹（lib目录和dist目录）。 axios由于一个前后端都可以使用的库，前后端发出请求的方式不一样，前端使用xhr对象，后端使用的是http库，所以这里有一个browser字段表示在浏览器端把某一个文件的导入换成另外一个文件。 axios 的package.json没有module目录，说明如果模块被一个客户端应用使用的话，打包器的入口也是main指向的地址。这个main的地址指向了一个源文件，并不是打包后的文件。这里和之前的vuex有明显的不一样。 思考一个包（模块）在一个应用中是如何被使用的？ 一般来说会有两种方式 直接通过script标签引入 通过require或者import方式引入，加上打包工具(webpack, rollup) 第一种方式通常会使用一个dist目录的压缩版本的umd格式的包，使用cdn或者其他方式引入。此处不细讲。 前面我们说到，打包工具一般会使用module/main 字段作为包的入口文件。这里先讨论main，main一般来说会有三种取值 指向源代码文件 （如axios） 指向打包后的开发版本（如vuex） 指向打包后的生产版本 先讨论第一种与第二中的区别 如果使用源码作为入口文件的话，就需要使用者自行对这个模块进行打包处理，而由于使用webpack这类打包工具的时候，往往会配置babel-loader 把node_modules给exclude掉，这也就意味着不会对这个包进行转译。如果这个包里出现了es6或者更高级的特性的话，可能会在应用层上会出现不兼容的问题。而且对node_modules里的包进行处理，会导致编译速度变慢。 所以如果是在客户端使用的包，包的开发者不应该使用源代码作为入口。如果包的目标运行环境只是在node端，由于node端不需要对源代码进行编译打包，所以可以将源文件作为入口文件。 再讨论第二种与第三种的区别： 我们看到vuex的module字段指向的是一个开发版本的编译包。开发版本和生产版本有什么区别呢？ 开发版本一般不会进行压缩，利于在包的使用者在开发过程中进行调试，保持源代码的可读性。 开发版本一般会有一些警告信息。这些警告信息，一般源码是这样实现的，这些代码一样会被放到开发版本的包文件中。 123if (process.env.NODE_ENV === 'development') &#123; console.warn()&#125; 如果使用webpack的话，会使用DefinePlugin来定义环境变量。如果在开发环境的话，NODE_ENV就是’development’了，那么警告信息就会被打印出来。 所以可以看到vuex的module和main指向的不同模块格式的开发版本的包，这让你在开发的时候，有很好的开发体验，会有报错信息。 等你将你的应用代码打包上线的时候，打包工具会将环境变量设置为production，那么那些所有的判断都为false了，所以就不会进入那些警告的逻辑了。同时，还会启用minify将代码进行压缩，会删除用不到的代码。所以生产版本就看不到警告了。 再看开源库前面我们看了vuex和axios，看起来vuex的实现更加标准一些。axios的只有一个main字段（client 和server端公用一个入口），如果使用者不加转译的话，axios里如果用了一些目标浏览器不支持的新特性的话，就会出现兼容性问题。 axios和vuex都将dist目录推送到github 再看mobx的实现， mobx和axios一样可以在client,server端使用。 123456789101112&#123; \"main\": \"lib/index.js\", \"umd:main\": \"lib/mobx.umd.js\", \"module\": \"lib/mobx.module.js\", \"unpkg\": \"lib/mobx.umd.min.js\", \"jsnext:main\": \"lib/mobx.module.js\", \"typings\": \"lib/mobx.esm.js\", \"files\": [ \"lib\", \"LICENSE\" ],&#125; 这里main指向的是源码文件，其他的都是打包后的文件。而且还要知道的是mobx并没有把lib目录push到github，而只是把lib目录push到了npm上。 参考： 关于package.json中main字段的指向问题 npm doc","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"},{"name":"工程化","slug":"工程化","permalink":"http://colgin.com/tags/工程化/"}]},{"title":"koa源码","slug":"koa源码","date":"2020-05-23T10:51:26.000Z","updated":"2020-05-23T11:00:53.502Z","comments":true,"path":"2020/05/23/koa源码/","link":"","permalink":"http://colgin.com/2020/05/23/koa源码/","excerpt":"Koa是Node应用广泛的后端框架，它的“洋葱”模型被人津津乐道，Koa源码实现也非常简练，那就一起来看下Koa的源码吧。","text":"Koa是Node应用广泛的后端框架，它的“洋葱”模型被人津津乐道，Koa源码实现也非常简练，那就一起来看下Koa的源码吧。 工程化1234567891011121314151617# .editorconfig# editorconfig.orgroot = true[*]indent_style = spaceindent_size = 2end_of_line = lfcharset = utf-8trim_trailing_whitespace = trueinsert_final_newline = true[*.md]trim_trailing_whitespace = false[Makefile]indent_style = tab 123456789101112131415161718192021# .travis.ymllanguage: node_jsnode_js: - 8 - 10 - 12cache: directories: - wrk/bin - node_modulesbefore_script: - npm prune - \"[ ! -f wrk/bin/wrk ] &amp;&amp; rm -rf wrk &amp;&amp; git clone https://github.com/wg/wrk.git &amp;&amp; make -C wrk &amp;&amp; mkdir wrk/bin &amp;&amp; mv wrk/wrk wrk/bin || true\" - export PATH=$PATH:$PWD/wrk/bin/script: - npm run lint - npm run test-cov - npm run benchafter_script: # only upload the coverage.json file - bash &lt;(curl -s https://codecov.io/bash) -f coverage/coverage-final.json npm prune会移除无关的包，所谓无关指的是没有在父包的依赖关系列表中列出的包。参考npm prune wrk是一个http测试工具 1wrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html 意思就是看看30s，用12个线程，开400个http连接能处理多少个http请求。 再看package.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; \"name\": \"koa\", \"version\": \"2.12.0\", \"description\": \"Koa web app framework\", \"main\": \"lib/application.js\", \"scripts\": &#123; \"test\": \"egg-bin test test\", \"test-cov\": \"egg-bin cov test\", \"lint\": \"eslint benchmarks lib test\", \"bench\": \"make -C benchmarks\", \"authors\": \"git log --format='%aN &lt;%aE&gt;' | sort -u &gt; AUTHORS\" &#125;, \"repository\": \"koajs/koa\", \"keywords\": [ \"web\", \"app\", \"http\", \"application\", \"framework\", \"middleware\", \"rack\" ], \"license\": \"MIT\", \"dependencies\": &#123; \"accepts\": \"^1.3.5\", \"cache-content-type\": \"^1.0.0\", \"content-disposition\": \"~0.5.2\", \"content-type\": \"^1.0.4\", \"cookies\": \"~0.8.0\", \"debug\": \"~3.1.0\", \"delegates\": \"^1.0.0\", \"depd\": \"^1.1.2\", \"destroy\": \"^1.0.4\", \"encodeurl\": \"^1.0.2\", \"escape-html\": \"^1.0.3\", \"fresh\": \"~0.5.2\", \"http-assert\": \"^1.3.0\", \"http-errors\": \"^1.6.3\", \"is-generator-function\": \"^1.0.7\", \"koa-compose\": \"^4.1.0\", \"koa-convert\": \"^1.2.0\", \"on-finished\": \"^2.3.0\", \"only\": \"~0.0.2\", \"parseurl\": \"^1.3.2\", \"statuses\": \"^1.5.0\", \"type-is\": \"^1.6.16\", \"vary\": \"^1.1.2\" &#125;, \"devDependencies\": &#123; \"egg-bin\": \"^4.13.0\", \"eslint\": \"^6.5.1\", \"eslint-config-koa\": \"^2.0.0\", \"eslint-config-standard\": \"^14.1.0\", \"eslint-plugin-import\": \"^2.18.2\", \"eslint-plugin-node\": \"^10.0.0\", \"eslint-plugin-promise\": \"^4.2.1\", \"eslint-plugin-standard\": \"^4.0.1\", \"mm\": \"^2.5.0\", \"supertest\": \"^3.1.0\" &#125;, \"engines\": &#123; \"node\": \"^4.8.4 || ^6.10.1 || ^7.10.1 || &gt;= 8.1.4\" &#125;, \"files\": [ \"lib\" ]&#125; 这里需要留意的是有一个authors命令, git log --format=&#39;%aN &lt;%aE&gt;&#39; | sort -u &gt; AUTHORS 这条命令是把git 提交记录的姓名和邮件排序输出到AUTHORS文件。 核心代码入口入口是application.js 先看构造函数 12345678910111213141516171819202122232425262728293031323334353637module.exports = class Application extends Emitter &#123; /** * Initialize a new `Application`. * * @api public */ /** * * @param &#123;object&#125; [options] Application options * @param &#123;string&#125; [options.env='development'] Environment * @param &#123;string[]&#125; [options.keys] Signed cookie keys * @param &#123;boolean&#125; [options.proxy] Trust proxy headers * @param &#123;number&#125; [options.subdomainOffset] Subdomain offset * @param &#123;boolean&#125; [options.proxyIpHeader] proxy ip header, default to X-Forwarded-For * @param &#123;boolean&#125; [options.maxIpsCount] max ips read from proxy ip header, default to 0 (means infinity) * */ constructor(options) &#123; super(); options = options || &#123;&#125;; this.proxy = options.proxy || false; this.subdomainOffset = options.subdomainOffset || 2; this.proxyIpHeader = options.proxyIpHeader || 'X-Forwarded-For'; this.maxIpsCount = options.maxIpsCount || 0; this.env = options.env || process.env.NODE_ENV || 'development'; if (options.keys) this.keys = options.keys; this.middleware = []; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); if (util.inspect.custom) &#123; this[util.inspect.custom] = this.inspect; &#125; &#125;&#125; 就是一些初始化流程，把options的一些选项挂在到this上。这里有一个要留意的是代理相关的配置。 12345listen(...args) &#123; debug('debug') const server = http.createServer(this.callback()) return server.listen(...args)&#125; 这里http.createServer接收的是一个function(req, res) {}函数，这里调用了calllback生成这样一个函数。这样的设计使得可以将callback生成的处理器放到任何能够接受监听器函数中用于启动一个服务，比如说http.createServer或者express。 12345678910callback() &#123; const fn = compose(this.middleware) if (!this.listenerCount('error)) this.on('error', this.onerror) const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res) return this.handleRequest(ctx, fn) &#125;&#125; 这里主要就是构造出一个上下文对象，然后在handleRequest里去处理这个请求。 先看下创建上下文的函数createContext吧 1234567891011121314createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = &#123;&#125;; return context; &#125; 前面构造函数中对this.context, this.request, this.response进行了初始化 123this.context = Object.create(context);this.request = Object.create(request);this.response = Object.create(response); createContext做的就是给context变量里的req,res,ctx进行赋值，吧res和req不仅挂到了context上，还挂到了contex.request, context.response上。 接下来看一下koa为人津津乐道的插件机制。在koa github主页上有这么一段话介绍koa Expressive HTTP middleware framework for node.js to make web applications and APIs more enjoyable to write. Koa’s middleware stack flows in a stack-like manner, allowing you to perform actions downstream then filter and manipulate the response upstream koa提供了一个web框架的核心部分，不包含路由处理，静态文件处理（这些都是通过中间件来实现），我们经常会把这种叫做洋葱模型。 ! 实际使用中使用use来给koa应用注册中间件，中间件按照注册顺序按序调用，前面的中间件可以调用next()来控制下一个中间件的执行。 1234567891011121314151617181920212223242526const Koa = require('koa');const app = new Koa();// loggerapp.use(async (ctx, next) =&gt; &#123; await next(); const rt = ctx.response.get('X-Response-Time'); console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`);&#125;);// x-response-timeapp.use(async (ctx, next) =&gt; &#123; const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set('X-Response-Time', `$&#123;ms&#125;ms`);&#125;);// responseapp.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;);app.listen(3000); 通过中间件可以做到调用下游，控制流回上游 那这个是怎么实现的呢？先来看use的实现 123456789101112use(fn) &#123; if (typeof fn !== 'function') throw new TypeError('middleware must be a function!'); if (isGeneratorFunction(fn)) &#123; deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md'); fn = convert(fn); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this; &#125; use函数实现非常简单，就是把注册进来中间件函数(context, next) ⇒ {} 存放到实例的middleware里面。那么这个middleware是怎么起作用的呢？ 细心的你可能在之前的callback 函数中发现有这样一行 1const fn = compose(this.middleware) 这行代码就是实现中间件的精髓。compose将所有的中间件组合成一个函数。 先不看官方的实现，我们可以自己实现一个这样的compose函数 1234567891011121314const compose = (middlewares) =&gt; (ctx) =&gt; &#123; const dispatch = (i) =&gt; &#123; const fn = middlewares[i] // 最后一个中间件调用next不能报错 if (!fn) &#123; return Promise.resolve() &#125; return Promise.resolve(fn(ctx, () =&gt; dispatch(i + 1))) &#125; dispatch(0)&#125; 可以看到，compose生成了一个新的函数，在这个函数中我们把ctx传入进去，所有的中间件都会执行，执行的顺序通过给中间件函数传递的第二个参数来控制，也就是说把在第n+1个中间件函数的执行权交给第n个中间件函数。 koa实际是使用了koa/compose。这里一并把代码贴出来 123456789101112131415161718192021222324252627282930313233343536373839404142module.exports = compose/** * Compose `middleware` returning * a fully valid middleware comprised * of all those which are passed. * * @param &#123;Array&#125; middleware * @return &#123;Function&#125; * @api public */function compose (middleware) &#123; if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') for (const fn of middleware) &#123; if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') &#125; /** * @param &#123;Object&#125; context * @return &#123;Promise&#125; * @api public */ return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 相对于简陋版本的compose来说，这里的compose考虑了不能在一个中间件中调用多次next，还处理了最后一个中间件不调用next的情况。 Koa构造函数还有两个函数，toJSON, inspect，这俩函数就是返回指定的几个字段。 1234567891011121314151617181920212223242526/** * Return JSON representation. * We only bother showing settings. * * @return &#123;Object&#125; * @api public */ toJSON() &#123; return only(this, [ 'subdomainOffset', 'proxy', 'env' ]); &#125; /** * Inspect implementation. * * @return &#123;Object&#125; * @api public */ inspect() &#123; return this.toJSON(); &#125; 再看下处理请求的部分，处理请求包括错误处理，数据响应。这里有一个onFinished(res, onerror)是在响应结束或者关闭或者错误的时候执行一下onerror方法。on-finished 123456789handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res res.statusCode = 404 const onerror = err =&gt; ctx.onerror(err) const handleResponse = () =&gt; respond(ctx) onFinished(res, onerror) return fnMiddleware(ctx).then(handleResponse).catch(onerror)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function respond(ctx) &#123; // allow bypassing koa if (false === ctx.respond) return if (!ctx.writable) return const res = ctx.res let body = ctx.body const code = ctx.status; // statuses.empty(code) returns true if a status code expects an empty body if (statuses.empty[code]) &#123; // strip headers ctx.body = null return res.end() &#125; if ('HEAD' === ctx.method) &#123; if (!res.headersSent &amp;&amp; !ctx.response.has('Content-Length')) &#123; const &#123; length &#125; = ctx if (Number.isInteger(length)) ctx.length = length &#125; return res.end() &#125; // status body if (null === body) &#123; if (ctx.reponse._expliciNullBody) &#123; ctx.response.remove('Content-Type') ctx.response.remove('Transfer-Encoding') return res.end() &#125; if (ctx.req.httpVersionMajaor &gt;= 2) &#123; body = String(code) &#125; else &#123; body = ctx.message || String(code) &#125; if (!res.headersSend) &#123; ctx.type = 'text' ctx.length = Buffer.byteLength(body) &#125; return res.end(body) &#125; // responses if (Buffer.isBuffer(body)) return res.end(body) if ('string' === typeof body) return res.end(body) if (body instanceof Stream) return body.pipe(res) // body: json body = JSON.stringify(body) if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body) &#125; res.end(body)&#125; 这里处理了不同类型的body，这里可以看到如果res.headersSent为false的话，会写一些header。 context, request, response context123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105const COOKIES = Symbol('context#cookies')const proto = module.exports = &#123; inspect() &#123; if (this === proto) return this return this.toJSON() &#125;, // 返回对象的所有json表示 toJSON() &#123; return &#123; request: this.request.toJSON(), response: this.response.toJSON(), app: this.app.toJSON(), originalUrl: this.originalUrl, req: '&lt;original node req&gt;', res: '&lt;original node res&gt;', socket: '&lt;original node socket&gt;' &#125; &#125;, // assertion assert: httpAssert, // throw error throw(...arg) &#123; throw createError(...args) &#125;, // default error handling onerror(err) &#123; // &#125;, // cookies get cookies() &#123; if (!this[COOKIES]) &#123; this[COOKIES] = new Cookie(this.req, this.res, &#123; keys: this.app.keys, secure: this.request.secure &#125;) &#125; &#125;, set cookies(_cookies) &#123; this[COOKIES] = _cookies &#125;&#125;/** * Response delegation. */delegate(proto, 'response') .method('attachment') .method('redirect') .method('remove') .method('vary') .method('has') .method('set') .method('append') .method('flushHeaders') .access('status') .access('message') .access('body') .access('length') .access('type') .access('lastModified') .access('etag') .getter('headerSent') .getter('writable');/** * Request delegation. */delegate(proto, 'request') .method('acceptsLanguages') .method('acceptsEncodings') .method('acceptsCharsets') .method('accepts') .method('get') .method('is') .access('querystring') .access('idempotent') .access('socket') .access('search') .access('method') .access('query') .access('path') .access('url') .access('accept') .getter('origin') .getter('href') .getter('subdomains') .getter('protocol') .getter('host') .getter('hostname') .getter('URL') .getter('header') .getter('headers') .getter('secure') .getter('stale') .getter('fresh') .getter('ips') .getter('ip'); context里写了很多setter，getter,并且使用delegate把request，response的东西挂到委托到context上。 request123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const IP = Symbol('context#ip')module.exports = &#123; get header() &#123; return this.req.headers &#125;, set header(val) &#123; this.req.headers = val &#125;, get url() &#123; return this.req.url &#125;, set url(val) &#123; this.req.url = val &#125;, get method() &#123; return this.req.method &#125;, set method(val) &#123; this.req.method = val &#125;, get query() &#123; const str = this.querystring; const c = this._querycache = this._querycache || &#123;&#125;; return c[str] || (c[str] = qs.parse(str)) &#125;, set query(obj) &#123; this.querystring = q.stringify(obj) &#125;, get querystring() &#123; if (!this.req) return '' return parse(this.req).query || '' &#125;, set querystring() &#123; const url = parse(this.req) if (url.search === `?$&#123;str&#125;`) return; url.search = str url.patch = null this.url = stringify(url) &#125;, get socket() &#123; return this.socket &#125;, get length() &#123; const len = this.get('Content-Length') if (len === '') return return ~~len &#125;, /** * Return request's remote address * When `app.proxy` is `true`, parse * the \"X-Forwarded-For\" ip address list and return the first one * * @return &#123;String&#125; * @api public */ get ip() &#123; if (!this[IP]) &#123; this[IP] = this.ips[0] || this.socket.remoteAddress || ''; &#125; return this[IP]; &#125;, set ip(_ip) &#123; this[IP] = _ip; &#125;, get(field) &#123; const req = this.req; switch (field = field.toLowerCase()) &#123; case 'referer': case 'referrer': return req.headers.referrer || req.headers.referer || ''; default: return req.headers[field] || ''; &#125; &#125;, /** * Return JSON representation. * * @return &#123;Object&#125; * @api public */ toJSON() &#123; return only(this, [ 'method', 'url', 'header' ]); &#125;&#125; 可以看到这里也都是一些setter，getter，还有一些封装的方法比如get。 不过从代码中可以学习到一些编码技巧。 12const c = this._querycache = this._querycache || &#123;&#125;; // 存只避免多次访问return ~~len // 位运算，这里相当于parseInt 位运算参考文章 位运算符在JS中的妙用 上面代码还有一个比较意思的是，cookies和ip的访问都是用了Symbol。原因参考 response与request 类似，不再贴代码。 测试在package.json里script中 1234567\"scripts\": &#123; \"test\": \"egg-bin test test\", \"test-cov\": \"egg-bin cov test\", \"lint\": \"eslint benchmarks lib test\", \"bench\": \"make -C benchmarks\", \"authors\": \"git log --format='%aN &lt;%aE&gt;' | sort -u &gt; AUTHORS\"&#125;, 可以看到这里功能测试使用的是egg-bin（mocha） 基准测试make -C benchmarks ，首先可以了解一下make。-C是改变Makefile的读取目录，这里意思就是去benchmark目录下找Makefile文件。 1234567891011121314151617181920212223// benchmark/Makefileall: middlewaremiddleware: @./run 1 false $@ @./run 5 false $@ @./run 10 false $@ @./run 15 false $@ @./run 20 false $@ @./run 30 false $@ @./run 50 false $@ @./run 100 false $@ @./run 1 true $@ @./run 5 true $@ @./run 10 true $@ @./run 15 true $@ @./run 20 true $@ @./run 30 true $@ @./run 50 true $@ @./run 100 true $@ @echo.PHONY: all middleware 123456789101112131415161718192021222324252627282930// benchmark/middleware.js'use strict';const Koa = require('..');const app = new Koa();// number of middlewarelet n = parseInt(process.env.MW || '1', 10);const useAsync = process.env.USE_ASYNC === 'true';console.log(` $&#123;n&#125;$&#123;useAsync ? ' async' : ''&#125; middleware`);while (n--) &#123; if (useAsync) &#123; app.use(async(ctx, next) =&gt; next()); &#125; else &#123; app.use((ctx, next) =&gt; next()); &#125;&#125;const body = Buffer.from('Hello World');if (useAsync) &#123; app.use(async(ctx, next) =&gt; &#123; await next(); ctx.body = body; &#125;);&#125; else &#123; app.use((ctx, next) =&gt; next().then(() =&gt; ctx.body = body));&#125;app.listen(3333); 功能测试测试代码就不看了，有兴趣自己去github上看看。","categories":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"}]},{"title":"如何优雅关机重启.md","slug":"如何优雅关机重启","date":"2020-04-24T16:01:41.000Z","updated":"2020-04-24T16:07:18.385Z","comments":true,"path":"2020/04/25/如何优雅关机重启/","link":"","permalink":"http://colgin.com/2020/04/25/如何优雅关机重启/","excerpt":"背景web项目有时候需要更新迭代或者更新项目的配置文件，这时候需要重启web服务，然而不能简单粗暴的关机，这样会导致当前接受到的socket会处理失败。优雅的关机应该是拒绝新的socket连接，等待正在处理的socket连接处理完成再退出。","text":"背景web项目有时候需要更新迭代或者更新项目的配置文件，这时候需要重启web服务，然而不能简单粗暴的关机，这样会导致当前接受到的socket会处理失败。优雅的关机应该是拒绝新的socket连接，等待正在处理的socket连接处理完成再退出。 优雅的关机在go 1.8之后，net/http包有一个Shutdown方法。这个方法能够优雅的在不中断正在处理的请求连接的情况下关掉服务。实质上是通过关掉服务上的监听，关掉空闲的连接，然后无限制地等待正在处理的连接完成再关掉服务。 123456789101112131415161718192021222324252627282930313233343536// 来自官网的例子package mainimport ( \"context\" \"log\" \"net/http\" \"os\" \"os/signal\")func main() &#123; var srv http.Server idleConnsClosed := make(chan struct&#123;&#125;) go func() &#123; sigint := make(chan os.Signal, 1) signal.Notify(sigint, os.Interrupt) &lt;-sigint // We received an interrupt signal, shut down. if err := srv.Shutdown(context.Background()); err != nil &#123; // Error from closing listeners, or context timeout: log.Printf(\"HTTP server Shutdown: %v\", err) &#125; close(idleConnsClosed) &#125;() if err := srv.ListenAndServe(); err != http.ErrServerClosed &#123; // Error starting or closing listener: log.Fatalf(\"HTTP server ListenAndServe: %v\", err) &#125; &lt;-idleConnsClosed&#125; 可以看到这里开启了一个goroutine接收操作系统的信号，一旦接收到os.Interrupt就调用Shutdown()，再把idleConnsClosed通道给关掉，这样外面的代码就不会阻塞了，至此，函数执行完成。 上面的代码有几个可以优化点 不需要开启新的goroutine，直接在main函数里阻塞就行，这样也就不用特地使用一个通道（上例的idleConnsClosed）来通知外层不再阻塞 Shutdown()对于正在处理的请求，会无限期地等待连接被释放然后再关停。更好的方法是设置一个时间，恰好Shutdown()可以接收一个context,如果context比shutdown更早完成的话，就会返回一个context错误。 123456789101112131415161718func main() &#123; var srv http.Server // 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间） quit := make(chan os.Signal, 1) signal.Notify(quit, os.Interrupt) &lt;- quit // 阻塞 log.Println(\"Shutdown Server ...\") ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 在5s内关闭服务，超过5s就超时退出 if err := srv.Shutdown(ctx); err != nil &#123; log.Fatal(\"Server Shutdown\", err) &#125; log.Println(\"Server exiting\")&#125; 知识点补充：这里都是接受了os.Interrupt信号，其实在os.Interrupt就是syscall.SIGINT 除了SIGINT之外，还有很多其他的信号 12345678910111213141516const ( // More invented values for signals SIGHUP = Signal(0x1) SIGINT = Signal(0x2) SIGQUIT = Signal(0x3) SIGILL = Signal(0x4) SIGTRAP = Signal(0x5) SIGABRT = Signal(0x6) SIGBUS = Signal(0x7) SIGFPE = Signal(0x8) SIGKILL = Signal(0x9) SIGSEGV = Signal(0xb) SIGPIPE = Signal(0xd) SIGALRM = Signal(0xe) SIGTERM = Signal(0xf)) 可以在终端上执行kill -l查看系统支持的信号。我们常常通过kill -9 pid这种方式来强制关闭进程，本质上就是给进程发送一个SIGKILL信号（此信号不能被程序捕捉）。同理kill -2 pid就是发送SIGINT信号，kill pid默认会发送SIGTERM信号。有时候使用Ctrl+C来中止程序，其发送的是SIGINT信号。 具体的请参考unix信号 如果是在go1.8之前，可以使用一些库来实现优雅关机: manners graceful 优雅的重启可以使用fvbock/endless来替换默认的listener实现优雅重启。 可以简单看一下endless源码123456789101112131415161718192021222324252627282930313233343536373839404142/*handleSignals listens for os Signals and calls any hooked in function that theuser had registered with the signal.*/func (srv *endlessServer) handleSignals() &#123; var sig os.Signal signal.Notify( srv.sigChan, hookableSignals..., ) pid := syscall.Getpid() for &#123; sig = &lt;-srv.sigChan srv.signalHooks(PRE_SIGNAL, sig) switch sig &#123; case syscall.SIGHUP: log.Println(pid, \"Received SIGHUP. forking.\") err := srv.fork() if err != nil &#123; log.Println(\"Fork err:\", err) &#125; case syscall.SIGUSR1: log.Println(pid, \"Received SIGUSR1.\") case syscall.SIGUSR2: log.Println(pid, \"Received SIGUSR2.\") srv.hammerTime(0 * time.Second) case syscall.SIGINT: log.Println(pid, \"Received SIGINT.\") srv.shutdown() case syscall.SIGTERM: log.Println(pid, \"Received SIGTERM.\") srv.shutdown() case syscall.SIGTSTP: log.Println(pid, \"Received SIGTSTP.\") default: log.Printf(\"Received %v: nothing i care about...\\n\", sig) &#125; srv.signalHooks(POST_SIGNAL, sig) &#125;&#125; 可以看到他就是监听了很多信号 在接收到SIGHUP信号时候将会出发fork实现重启。 在接收到SIGINT和SIGTERM时会触发优雅关机 在接收到SIGUSR2时会调用hanmerTime 这样的话，就可以通过发送kill -1 pid来实现优雅重启了。由于优雅重启使用的是fork，fork子进程处理新请求，待原进程处理完当前请求之后在退出。所以前后的pid会发生变化。 除了fvbock/endless，还可使用grace来实现优雅关机和重启。 参考资料 Gin Web Framework(https://gin-gonic.com/zh-cn/docs/examples/graceful-restart-or-stop/) 优雅地关机或重启 wikipedia unix信号 Graceful Restart in Golang","categories":[{"name":"Golang","slug":"Golang","permalink":"http://colgin.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://colgin.com/tags/Golang/"},{"name":"后端","slug":"后端","permalink":"http://colgin.com/tags/后端/"},{"name":"web","slug":"web","permalink":"http://colgin.com/tags/web/"}]},{"title":"Vue中的Portal技术","slug":"Vue中的Portal技术","date":"2019-07-27T06:54:32.000Z","updated":"2019-07-27T06:57:05.806Z","comments":true,"path":"2019/07/27/Vue中的Portal技术/","link":"","permalink":"http://colgin.com/2019/07/27/Vue中的Portal技术/","excerpt":"Vue 中的 Portal 技术在 Vue 项目中，我们使用模板来声明 dom 嵌套关系，然而有时候一些组件需要脱离固定的层级关系，不再受制与层叠上下文，比如说 Modal 和 Dialog 这种组件就希望能够脱离当前模板所在的层叠上下文。 在 Vue 中有两种方式来实现这种效果，一种是使用指令，操作真实 dom，使用熟知的 dom 操作方法将指令所在的元素 append 到另外一个 dom 节点上去。另一种方式就是定义一套组件，将组件内的 vnode 转移到另外一个组件中去，然后各自渲染。","text":"Vue 中的 Portal 技术在 Vue 项目中，我们使用模板来声明 dom 嵌套关系，然而有时候一些组件需要脱离固定的层级关系，不再受制与层叠上下文，比如说 Modal 和 Dialog 这种组件就希望能够脱离当前模板所在的层叠上下文。 在 Vue 中有两种方式来实现这种效果，一种是使用指令，操作真实 dom，使用熟知的 dom 操作方法将指令所在的元素 append 到另外一个 dom 节点上去。另一种方式就是定义一套组件，将组件内的 vnode 转移到另外一个组件中去，然后各自渲染。 使用指令典型的实现有vue-dom-portal,vux transfer,iview transfer 这里以vue-dom-portal为例，代码非常简单无非就是将当前的 dom 移动到指定地方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Get target DOM Node * @param &#123;(Node|string|Boolean)&#125; [node=document.body] DOM Node, CSS selector, or Boolean * @return &#123;Node&#125; The target that the el will be appended to */function getTarget(node = document.body) &#123; if (node === true) return document.body; return node instanceof window.Node ? node : document.querySelector(node);&#125;const homes = new Map();const directive = &#123; inserted(el, &#123; value &#125;, vnode) &#123; const &#123; parentNode &#125; = el; const home = document.createComment(\"\"); let hasMovedOut = false; if (value !== false) &#123; parentNode.replaceChild(home, el); // moving out, el is no longer in the document getTarget(value).appendChild(el); // moving into new place hasMovedOut = true; &#125; if (!homes.has(el)) homes.set(el, &#123; parentNode, home, hasMovedOut &#125;); // remember where home is or should be &#125;, componentUpdated(el, &#123; value &#125;) &#123; // need to make sure children are done updating (vs. `update`) const &#123; parentNode, home, hasMovedOut &#125; = homes.get(el); // recall where home is if (!hasMovedOut &amp;&amp; value) &#123; // remove from document and leave placeholder parentNode.replaceChild(home, el); // append to target getTarget(value).appendChild(el); homes.set(el, Object.assign(&#123;&#125;, homes.get(el), &#123; hasMovedOut: true &#125;)); &#125; else if (hasMovedOut &amp;&amp; value === false) &#123; // previously moved, coming back home parentNode.replaceChild(el, home); homes.set(el, Object.assign(&#123;&#125;, homes.get(el), &#123; hasMovedOut: false &#125;)); &#125; else if (value) &#123; // already moved, going somewhere else getTarget(value).appendChild(el); &#125; &#125;, unbind(el, binding) &#123; homes.delete(el); &#125;&#125;;function plugin(Vue, &#123; name = \"dom-portal\" &#125; = &#123;&#125;) &#123; Vue.directive(name, directive);&#125;plugin.version = \"0.1.6\";export default plugin;if (typeof window !== \"undefined\" &amp;&amp; window.Vue) &#123; window.Vue.use(plugin);&#125; 可以看到在 inserted 的时候就拿到实例的 el（真实 dom），然后进行替换操作，在 componentUpdated 的时候再次根据指令的值去操作 dom。为了能够在不同声明周期函数中使用缓存的一些数据，这里在 inserted 的时候就把当前节点的父节点和替换成的 dom 节点（一个注释节点）,以及节点是否移出去的状态都记录在外部的一个 map 中，这样可以在其他的声明周期函数中使用，可以避免重复计算。 类似的还有iview transfer，略微有些不同的是，共享的一些状态变量是挂载在 el 的属性上面。 使用组件对典型地是portal-vue，声明了一对组件 Portal,PortalTarget。在 portal 中指定 name，可以将 portal 里的内容转移到具有相同 name 的 PortalTarget 中显示。原理就是在 mounted, updated 的时候将 Portal 的 vnode 存到一个公共空间，然后重写 Portal 的 render 函数，PortalTarget 在渲染时则是去公共空间中去寻找符合条件的 vnode，将其渲染出来。 有一个简化版本simple-portal-vue利于理解，这个公共空间就是一个 vue 实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// wormhole.js 公共空间import Vue from \"vue\";const Wormhole = Vue.extend(&#123; data() &#123; return &#123; transports: &#123;&#125; &#125;; &#125;, methods: &#123; open(transport) &#123; const &#123; to, passengers &#125; = transport; transport.passengers = Object.freeze(passengers); if (!this.transports[to]) &#123; Vue.set(this.transports, to, []); &#125; const currentIndex = this.getTransportIndex(transport); const newTransports = [...this.transports[to]]; if (currentIndex === -1) &#123; newTransports.push(transport); &#125; else &#123; newTransports[currentIndex] = transport; &#125; this.transports[to] = newTransports; &#125;, close(transport, force = false) &#123; const &#123; to &#125; = transport; if (!this.transports[to]) &#123; return; &#125; if (force) &#123; this.transports[to] = []; &#125; else &#123; const index = this.getTransportIndex(transport); if (index !== -1) &#123; const newTransports = [...this.transports[to]]; newTransports.splice(index, 1); this.transports[to] = newTransports; &#125; &#125; &#125;, getTransportIndex(&#123; to, from &#125;) &#123; return this.transports[to].findIndex( transport =&gt; transport.from === from ); &#125; &#125;&#125;);const wormhole = new Wormhole();export default wormhole; 这个导出的 wormhole 对象是唯一的，不同 portal，portal-target 读取到的数据都是同一份。这里利用了 vue 实例的响应式，将对应关系都存在 data 的 transports 里面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// portal.jsimport wormhole from \"./wormhole\";let pid = 1;export default &#123; name: \"portal\", props: &#123; to: &#123; type: String, required: true &#125;, name: &#123; type: String, default() &#123; return String(pid++); &#125; &#125; &#125;, mounted() &#123; this.sendUpdate(); &#125;, updated() &#123; this.sendUpdate(); &#125;, beforeDestroy() &#123; this.clear(); &#125;, methods: &#123; normalizedSlots() &#123; return this.$scopedSlots.default ? [this.$scopedSlots.default] : this.$slots.default; &#125;, sendUpdate() &#123; const slotContent = this.normalizedSlots(); if (slotContent) &#123; wormhole.open(&#123; from: this.name, to: this.to, passengers: [...slotContent] &#125;); &#125; else &#123; this.clear(); &#125; &#125;, clear() &#123; wormhole.close(&#123; from: this.name, to: this.to &#125;); &#125; &#125;, render() &#123; return &lt;div class=\"v-portal\" style=\"display: none;\" /&gt;; &#125;&#125;; 在 portal 组件里，在 mounted 和 updated 的时候都会将 portal 组件里的内容经过整理后传给 wormhole 实例，所谓的整理好的内容其实就是组件的插槽里面的内容，类型是 Function[] | VNode[], 作用域插槽是一个 Function，普通的插槽是 VNode。参考vue api 文档 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// portal-target.jsimport wormhole from \"./wormhole\";export default &#123; name: \"portalTarget\", props: &#123; multiple: Boolean, slotProps: Object, name: &#123; type: String, required: true &#125; &#125;, created() &#123; if (!this.transports[this.name]) &#123; this.$set(this.transports, this.name, []); &#125; &#125;, data() &#123; return &#123; transports: wormhole.transports &#125;; &#125;, computed: &#123; ownTransports() &#123; const transports = this.transports[this.name] || []; if (this.multiple) &#123; return transports; &#125; else &#123; return transports.slice(-1); &#125; &#125;, passengers() &#123; const slotProps = this.slotProps || &#123;&#125;; return this.ownTransports.reduce((passengers, transport) =&gt; &#123; let newPassenger = transport.passengers[0]; if (typeof newPassenger === \"function\") &#123; newPassenger = newPassenger(slotProps); &#125; else &#123; newPassenger = transport.passengers; &#125; return passengers.concat(newPassenger); &#125;, []); &#125; &#125;, methods: &#123; children() &#123; return this.passengers.length === 0 ? this.$slots.default : this.passengers; &#125; &#125;, render() &#123; const children = this.children(); // Solves a bug where Vue would sometimes duplicate elements upon changing multiple or disabled const wrapperKey = this.ownTransports.length; return ( &lt;div class=\"portal-target\" key=&#123;wrapperKey&#125;&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;; 在 portal-target 里面要做的事情就是从 wormhole 里面把 name 值匹配的 vnode 取出来，然后把它渲染成一个 vnode 数组。普通插槽直接就是 vnode 数组，作用域插槽的值是一个函数，传入参数就可以转化为 vnode，然后在 render 函数中将这些 vnode 渲染出来即可。 上面这个例子很好地说明了 Portal-Vue 工作的原理，而真正的 Portal-Vue 还支持更加多的功能。而且 wormhole 不仅支持以一个实例导出，也支持以类的形式导出，这给了使用者更多的自由，而且所有的 Wormhole 实例都共享了一份数据。 123456789101112131415161718const transports = &#123;&#125;const targets = &#123;&#125;const sources = &#123;&#125;export const Wormhole = Vue.extend(&#123; data: () =&gt; (&#123; transports, targets, sources &#125;), methods: &#123; open() &#123;&#125;, close() &#123;&#125; &#125;&#125;const wormhole = new Wormhole()export &#123; wormhole &#125; 总结这两种方式各有长处，以组件形式实现的 Portal，功能比较多，而且灵活，但是要求使用者在模板中写两个组件，比较适合与比较复杂的业务场景。以指令形式实现的 Portal 功能相对简单，但是使用起来比较简单，只需要在需要迁移的节点上写上指令既可，比较适合在组件库中，因为你无法要求组件库的使用者在某某地方写一个 Portal-Target，而且组件库中一般就是将节点迁移到根节点中，形式比较固定。 参考： vue-dom-portal vux transfer iview transfer portal-vue simple-portal-vue","categories":[{"name":"Vue","slug":"Vue","permalink":"http://colgin.com/categories/Vue/"}],"tags":[{"name":"组件","slug":"组件","permalink":"http://colgin.com/tags/组件/"}]},{"title":"package.json中的browser字段","slug":"package-json中的browser字段","date":"2019-06-30T03:13:24.000Z","updated":"2019-06-30T03:21:38.920Z","comments":true,"path":"2019/06/30/package-json中的browser字段/","link":"","permalink":"http://colgin.com/2019/06/30/package-json中的browser字段/","excerpt":"package.json中的browser字段有时候，我们想要写一个能够跑在浏览器上和node上的包，但是由于二者在执行环境上有微弱的区别，比如浏览器上请求数据是用XMLHttpRequest对象，但是node上用的确是http或者https，诸如此类的差异还有很多。这就导致了我们要为浏览器端和node端准备不同的源文件，那我们要怎么区分不同的环境呢？","text":"package.json中的browser字段有时候，我们想要写一个能够跑在浏览器上和node上的包，但是由于二者在执行环境上有微弱的区别，比如浏览器上请求数据是用XMLHttpRequest对象，但是node上用的确是http或者https，诸如此类的差异还有很多。这就导致了我们要为浏览器端和node端准备不同的源文件，那我们要怎么区分不同的环境呢？ 依赖打包器的process.browser在此，以实现base64编码为例，在同一个入口文件，可以根据打包器提供的process.browser字段（在浏览器环境下为true，在node环境下为false）123456789if (process.browser) &#123;module.exports = function (string) &#123;return btoa(string)&#125;&#125; else &#123;module.exports = function (string) &#123;return Buffer.from(string, 'binary').toString('base64')&#125;&#125; 但是这种方式有一个很大的问题，打包器会在执行上诉代码中会为包引入polyfill，在这个例子中就是在浏览器中的Buffer实现buffer。这样打包出来的体积就会很大 使用package.json的browser字段npm doc上的解释如下 If your module is meant to be used client-side the browser field should be used instead of the main field. This is helpful to hint users that it might rely on primitives that aren’t available in Node.js modules. (e.g. window) 总而言之就是在浏览器环境下用来替换main字段，包的作者可以通过browser字段提示包中要替换掉哪些模块或者要替换掉哪些源文件的实现。 browser的用法有以下几种 browser为某一个单个的字符串替换main成为浏览器环境的入口文件 1\"browser\": \"./lib/browser/main.js\" browser为一个对象，声明要替换或者忽略的文件这种形式比较适合替换部分文件，不需要创建新的入口。key是要替换的module或者文件名，右侧是替换的 1234\"browser\": &#123;\"module-a\": \"./browser/module-a.js\",\"./server/module-b.js\": \"./browser/module-b.js\"&#125; 打包器在打包到浏览器环境时，会将来自module-a的替换为’./browser/module-a.js’。将文件’./server/module-b.js’的引入替换为’./browser/module-b.js’。 还可以使用布尔值防止将module加载到包中1234\"browser\": &#123;\"module-a\":false,\"./server/only.js\":\"./shims/server-only.js\"&#125; 这种写法module-a在浏览器环境中将不会被打包。 上面的所有写法的路径都是基于package.json文件地址。 需要注意的是如果你的包能在浏览器和node上无差异化地实现，就不需要browser字段了。 参考资料: [译] 怎样写一个能同时用于 Node 和浏览器的 JavaScript 包？ package.json 中 你还不清楚的 browser，module，main 字段优先级 package-browser-field-spec, 在 package.json 中，’browser’字段的规范文档","categories":[{"name":"工程化","slug":"工程化","permalink":"http://colgin.com/categories/工程化/"}],"tags":[{"name":"package.json","slug":"package-json","permalink":"http://colgin.com/tags/package-json/"}]},{"title":"Redis 初体验","slug":"Redis-初体验","date":"2017-12-06T07:45:59.000Z","updated":"2017-12-06T12:25:42.000Z","comments":true,"path":"2017/12/06/Redis-初体验/","link":"","permalink":"http://colgin.com/2017/12/06/Redis-初体验/","excerpt":"Redis是一个支持网络，可基于内存亦可持久化的日志型、key-value数据存储系统。支持string，list，set，zset(有序集合)，hash。而且操作都是原子性的（要么成功执行，要么完全不执行）。redis数据都是缓存在内存中的，和memcached的区别在于redis会周期性的把更新的数据写入磁盘或者把修改操作西写入追加的记录文件。实现master-slave（主从）同步。","text":"Redis是一个支持网络，可基于内存亦可持久化的日志型、key-value数据存储系统。支持string，list，set，zset(有序集合)，hash。而且操作都是原子性的（要么成功执行，要么完全不执行）。redis数据都是缓存在内存中的，和memcached的区别在于redis会周期性的把更新的数据写入磁盘或者把修改操作西写入追加的记录文件。实现master-slave（主从）同步。 Redis命令redis-server:启动服务器如果配置好了环境变量，可以直接运行redis-server.exe redis.windows.conf开启服务，其中redis.windows.conf是配置文件，省略则按照默认配置开启。如果没有配置好环境变量则需要在redis目录下执行该命令。 redis-cli:启动客户端如果配置好了环境变量，可以直接运行命令redis-cli或者redis-cli -h host -p port -a password启动redis客户端。启动完成之后可以在客户端执行PING命令检测redis服务是否启动（如果启动成功会出现PONG） Redis键管理Redis使用key-value的形式存储数据。Redis对键有各种设置，比如设置过期时间啊，修改键名称啊等等详情请查看redis键命令。 Redis字符串 设置指定key的值：SET key value =&gt; SET name jack 查询指定key的值：GET key =&gt; GET name 当然还有很多命令用于处理更加复杂的去设置值为字符串的键值对，比如同时设置多个key-value对，获取指定key所储存的字符串的长度。对key中储存的数字增一等。详情请查看redis string命令 Redis 哈希（hash）Redis hash是一个string类型的field和value的映射表，hash特别适合存储对象 同时将多个field-value对设置到哈希表key中：HMSET key field1 value1 [field2 value2] =&gt; HMSET info name jack age 22 将哈希表key中的字符field的值设为value：*HSET key field value** =&gt; HSET info name coco 获取存储在哈希表中指定key的所有字段和值：HGETALL key =&gt; HGETALL info 获取存储在哈希表中指定字段的值：HGET key field =&gt; HGET info name还有其他一些命令可以对hash表进行更加复杂的操作，比如获取哈希表中字段的数量，为哈希表key中的指定字段的整数值加上增量。详情请查看redis 哈希命令 Redis列表（list）Redis列表是简单的字符串列表，按照插入顺序排序。可以添加到一个元素到列表头（左边）或者尾部（右边） 将一个或多个值插入到列表头部：LPUSH key value1 [value2 value3] =&gt; LPUSH friend coco 将一个值插入到已存在的列表头部：LPUSHX key value =&gt; LPUSHX friend jack 获取列表指定范围内的元素：LRANGE key start end=&gt; LRANGE friend 0 10还有其他命令可以通过索引获取列表中的元素，获取列表长度，在指定位置插入等待详情请查看redis 列表命令 Redis集合（set）Redis的集合是String类型的无序集合，集合成员是唯一的，不能重复。Redis中集合是通过hash表实现的。 向集合添加一个或多个成员：SADD key member1 [member2] =&gt; SADD phone huawei 返回集合中的所有成员：SMEMBERS key =&gt; SMEMBERS phone还有其他命令可以实现更复杂的操作，比如返回成员数，移除一个成员详情请查看redis 集合命令 Redis 有序集合（sorted set）不允许重复的成员，和set不同的是每个元素都会关联一个double类型的分数。redis通过分数为集合中的成员进行从大到小的排序，有序集合的成员是唯一的。但是分数却可以重复。有序集合也是通过哈希表实现的。 向有序集合添加一个或多个成员，或者更新已存在成员的分数：ZADD key score member [score member2] =&gt; ZADD computer 1 thinkpad 通过索引区间返回有序集合指定区间的成员：ZRANGE key start end =&gt; ZRANGE computer 0 3还有其他命令可以移除一个或多个成员，获取有序集合的成员数等。详情请查看redis 有序集合 Redis HyperLogLogRedis HyperLogLog是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。基数就是不重复元素 添加指定元素到 HyperLogLog 中：PFADD key element [element] =&gt; PFADD exam math 返回给定HyperLogLog的基数估算值：PFCOUNT key详情请查看redis HyperLogLogRedis发布订阅（Pub/Sub）Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。 订阅一个或多个频道的信息：PSUBSCRIBE channel [channel] 将信息发送到指定的频道；PUBLISH channel message还有一些命令可以用于根据模式去订阅，以及退订详情请查看redis pub/sub Redis 事务（transactions）Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证： 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。一个事务从开始到执行会经历以下三个阶段： 开始事务。 命令入队。 执行事务。 标记一个事务块的开始：MULTI 执行所有事务块：EXEC 监视一个（或多个）key,如果事务执行之前之歌key被其他命令所改动，那么事务就被打断。详情请查看redis 事务 Redis脚本Redis脚本使用Lua解释器来执行脚本。（Redis内嵌了Lua环境） 执行Lua脚本：EVAL script numkeys key [key…] arg [arg…]详情请查看redis 脚本 Redis 连接用于连接Redis服务 查看服务是否运行：PING 验证密码是否正确：AUTH password 关闭当前连接： QUIT 切换到指定数据库：SELECT index详情请查看redis 连接 Redis服务器查看redis服务信息，管理redis服务 获取redis服务器各种信息和统计值：INFO [section]详情请查看redis 服务器","categories":[{"name":"后端","slug":"后端","permalink":"http://colgin.com/categories/后端/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://colgin.com/tags/redis/"}]},{"title":"Promise一些细节","slug":"Promise一些细节","date":"2017-12-03T05:42:08.000Z","updated":"2018-03-13T15:55:42.000Z","comments":true,"path":"2017/12/03/Promise一些细节/","link":"","permalink":"http://colgin.com/2017/12/03/Promise一些细节/","excerpt":"Promise一些细节Promise是抽象异步处理对象以及对其进行各种操作的组件。在Promise之前我们一直使用回调的形式来处理异步。1234567getAsync('file.txt',function(error,result) &#123; if(error) &#123; throw error &#125; else &#123; //处理结果 &#125;&#125;)","text":"Promise一些细节Promise是抽象异步处理对象以及对其进行各种操作的组件。在Promise之前我们一直使用回调的形式来处理异步。1234567getAsync('file.txt',function(error,result) &#123; if(error) &#123; throw error &#125; else &#123; //处理结果 &#125;&#125;) 这种方式的问题在于回调函数的参数基于约定，而且容易出现回调地狱问题。 Promise对象创建1234var promise = new Promise(function(resolve,reject) &#123; //异步处理 //处理结束后，调用resolve或reject&#125;) promise对象有三种状态 unresolved-Pending：就是promise对象刚刚创建后的初始化状态 has-resolution-Fulfilled：resolve（成功）时，此时会调用onFulfilled has-rejection-Rejected：reject（失败）时，此时会调用onRejected状态从Pending转换为Fulfilled或Rejected后，这个promise对象的状态就不会发生任何变化。12345678910111213141516171819202122232425//一个实例了解promise function getURL(URL) &#123; return new Promise(function (resolve, reject) &#123; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;// 运行示例var URL = \"http://httpbin.org/get\";getURL(URL).then(function onFulfilled(value)&#123; console.log(value);&#125;).catch(function onRejected(error)&#123; console.error(error);&#125;); Promise静态方法Promise.resolve()静态方法Promise.resolve(value)可以认为是new Promise()方法的快捷方式。123456//下面两种方式效果一样Promise.resolve(48)new Promise(function(resolve) &#123; resolve(48)&#125;) 上诉两段代码会让返回一个promise对象，并且让这个promise对象立即进入resolved状态，并且将48传递给后面then里所指定的onFulfilled函数。仍然是异步调用。除此之外，Promise.resolve方法另一个方法就是讲thenable对象转换为promise对象。 thenable对象是ES6 Promises提出的一个概念，指的是一个具有.then方法的对象。使用Promise.resolve方法可以将thenable对象转换为promise对象，并且之后可以调用thenable对象本身的then方法1234var promise = Promise.resolve($.ajax('comment.json'))promise.then(function(value) &#123; console.log(value)&#125;) 上诉jQuery.ajax方法返回值是一个jqXHR Object对象(继承自Deferred Object)，但是Deferred Object并没有遵循Promises/A+或ES6 Promises标准。将Deferred Object对象转换成一个promise对象时，会出现缺失部分信息的问题。 Promise.rejectPromise.reject(error)同样是new Promise()的快捷方式123456//下面两种实现是一样的Promise.reject(new Error('出错了'))new Promise(function(resolve,reject) &#123; reject(new Error('出错了'))&#125;) Promise.all接收一个promise对象数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态时，才会调用.then方法。数组中的每个promise会同时执行，传递给then方法的参数也是和promise数组顺序 Promise.race接收一个promise对象数组为参数，只要有一个对象promise变为fulfilled或者rejected状态，就会继续进行后续的处理。 Promise实例方法promise的链式应用12345678910111213141516171819202122function taskA() &#123; console.log(\"Task A\"); throw new Error(\"throw Error @ Task A\")&#125;function taskB() &#123; console.log(\"Task B\");// 不会被调用&#125;function onRejected(error) &#123; console.log(error);// =&gt; \"throw Error @ Task A\"&#125;function finalTask() &#123; console.log(\"Final Task\");&#125;var promise = Promise.resolve();promise .then(taskA) .then(taskB) .catch(onRejected) .then(finalTask);//这里会依次输出Task A =&gt; throw Error @ Task A =&gt; Final Task 需要注意的是taskA中出错了，会跳过taskB，直接到catch,catch处理之后返回的仍然是一个promise对象，被认为了处理好了异常，然后调用下一个then。 promise#then 和 promise#catch实际上，promise.catch只是promise.then(undefined,onRejected)方法的一个别名。但在实际使用上还是有些区别的。12345678910111213141516171819function throwError(value) &#123; // 抛出异常 throw new Error(value);&#125;// &lt;1&gt; onRejected不会被调用function badMain(onRejected) &#123; return Promise.resolve(42).then(throwError, onRejected);&#125;// &lt;2&gt; 有异常发生时onRejected会被调用function goodMain(onRejected) &#123; return Promise.resolve(42).then(throwError).catch(onRejected);&#125;// 运行示例badMain(function()&#123; console.log(\"BAD\");&#125;);goodMain(function()&#123; console.log(\"GOOD\");&#125;); 上诉两种处理异常的手段区别显而易见，使用then指定第二个参数来做异常处理，不能捕获then第一个参数(onFulfilled)执行过程中抛出的错误。而使用catch则可以捕获到。原因在于.then方法中onRejected参数所指定的回调函数，实际上针对的是其promise对象或者之前的promise对象而不是.then方法里面指定的第一个参数，即onFulfilled所指向的对象。每次调用then,catch都会返回一个新创建的promise对象。而不是针对针对最初的promise对象进行一连串的链式调用。 Promise测试（Mocha）回调风格，使用done的Promise测试1234567it(\"should use `done` for test?\", function (done) &#123; var promise = Promise.resolve(42); promise.then(function (value) &#123; assert(value === 42); done(); &#125;);&#125;); 上诉代码会先创建Fulfilled的promise对象，然后调用done后测试结束123456it(\"should use `done` for test?\", function (done) &#123; var promise = Promise.resolve(); promise.then(function (value) &#123; assert(false); &#125;).then(done, done);&#125;); 上诉代码断言错误，如果不写下一个then的话，直接调用done()，这样测试会出问题的，原因在于then方法里面出错，状态会被promise捕获，测试框架对此一无所知。所以要在后面调用then来捕获。 Mocha对Promise的支持123456789var assert = require('power-assert');describe('Promise Test', function () &#123; it('should return a promise object', function () &#123; var promise = Promise.resolve(1); return promise.then(function (value) &#123; assert(value === 1); &#125;); &#125;);&#125;); 一些Tips使用reject而不是throw12345678910111213var promise = new Promise(function(resolve, reject)&#123; throw new Error(\"message\");&#125;);promise.catch(function(error)&#123; console.error(error);// =&gt; \"message\"&#125;);var promise = new Promise(function(resolve, reject)&#123; reject(new Error(\"message\"));&#125;);promise.catch(function(error)&#123; console.error(error);// =&gt; \"message\"&#125;) 上诉两种方法都是抛出异常。但是使用reject会更合理一些。因为我们很难区分throw是我们主动抛出来的，还是因为真正的异常导致的。 在then中reject12345678var onRejected = console.error.bind(console);var promise = Promise.resolve();promise.then(function () &#123; var retPromise = new Promise(function (resolve, reject) &#123; reject(new Error(\"this promise is rejected\")); &#125;); return retPromise;&#125;).catch(onRejected); 在then函数中注册的回调函数可以通过return返回一个值（任何JavaScript的合法值，包括undefined，thenable和promise），这个返回值会传给then或catch中的回调函数。如上所诉，同样也可以使用Promise。在then中reject。 12345var onRejected = console.error.bind(console);var promise = Promise.resolve();promise.then(function () &#123; return Promise.reject(new Error(\"this promise is rejected\"));&#125;).catch(onRejected); 消失的错误promise虽然具有强大的错误处理机制，但是（调试工具不能顺利运行的时候）这个功能会导致人为错误更加复杂，这也是它的一个缺点。123456789101112//下面这种异常很容易难排除function JSONPromise(value) &#123; return new Promise(function (resolve) &#123; //如果这里遇到非法的value，JSON.parse解析失败会抛出异常 resolve(JSON.parse(value)); &#125;);&#125;//比如这种syntax error（console拼写错误）var string = \"&#123;&#125;\";JSONPromise(string).then(function (object) &#123; conosle.log(object);&#125;); 由于Promise的try-catch机制，这个问题很可能会被内部消化掉。如果在调用的时候每次都无遗漏的进行catch处理的话当然最好了，但是如果在实现的过程中出现了这个例子中的错误，那么进行错误排除工作也变得困难。这种错误被内部消化的问题也被叫做unhandled rejection，就是在Rejected时没有找到相应处理的意思。针对上诉问题，一些库会有promise.done这个方法。用在链式调用的最末端，它不会反悔promise。123456789if (typeof Promise.prototype.done === \"undefined\") &#123; Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected).catch(function (error) &#123; setTimeout(function () &#123; throw error; &#125;, 0); &#125;); &#125;;&#125; 它会将异常抛到Promise的外面，使用setTimeout中的throw方法。 Promise一些易错点在then里面我们可以做以下三件事 return 另一个promise return 一个同步值（或者undefined） throw 一个同步异常 1promise2 = promise1.then(onFulfilled,onRejected) 根据Promise/A+规范。一个priomise对象的then方法必须返回返回一个Promise对象 如果onFulfilled或onRejected返回一个值，则用Promise.resolve将其包装成promise。 如果onFulfilled或onRejected抛出异常e，则promise2必须拒绝执行，并返回e 如果onFulfilled不是函数且promise1成功执行，promise2必须成功执行并返回相同的值 如果onRejected不是函数且promise1拒绝执行，promise必须拒绝执行并返回相同的拒因。 需要注意的是上面的返回：不论promise1被reject还是被resolve时promise2都会被resolve，只有出现异常时才会被rejected 1234567891011121314151617181920212223242526272829//返回一个promise，这里一定要注意使用return，要不然下一个函数将收到undefin而不是userAccountgetUserByName('nolan').then(function (user) &#123; return getUserAccountById(user.id);&#125;).then(function (userAccount) &#123; // I got a user account!&#125;);//return 一个同步值(或者同步值)getUserByName('nolan').then(function (user) &#123; if (inMemoryCache[user.id]) &#123; return inMemoryCache[user.id]; // returning a synchronous value! &#125; return getUserAccountById(user.id); // returning a promise!&#125;).then(function (userAccount) &#123; // I got a user account!&#125;);//throw一个异常getUserByName('nolan').then(function (user) &#123; if (user.isLoggedOut()) &#123; throw new Error('user logged out!'); // throwing a synchronous error! &#125; if (inMemoryCache[user.id]) &#123; return inMemoryCache[user.id]; // returning a synchronous value! &#125; return getUserAccountById(user.id); // returning a promise!&#125;).then(function (userAccount) &#123; // I got a user account!&#125;).catch(function (err) &#123; // Boo, I got an error!&#125;); promises vs promises factories有时候我们希望执行一个个的执行一个promises序列，类似Promise.all()但是并非并行执行所有promise。1234567function executeSequentially(promises) &#123; var result = Promise.resolve(); promises.forEach(function (promise) &#123; result = result.then(promise); &#125;); return result;&#125; 其实上诉代码是不行的。传入executeSequentially()的promises依然会并行执行。根据promise规范，一旦一个promise被创建，它就被执行了。所以这里需要一个promise factories数组。12345678910function executeSequentially(promiseFactories) &#123; var result = Promise.resolve(); promiseFactories.forEach(function (promiseFactory) &#123; result = result.then(promiseFactory); &#125;); return result;&#125;function myPromiseFactory() &#123; return somethingThatCreatesAPromise();&#125; 上诉代码可以达到目的，这是因为一个promise factory 在被执行之前并不会创建promise。我们可以理解为then函数理应接收一个函数，如果接收的是一个promise，并不会按照期望运行，因为promise被创建就被执行了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"http://colgin.com/tags/Promise/"},{"name":"异步","slug":"异步","permalink":"http://colgin.com/tags/异步/"}]},{"title":"构建web应用","slug":"构建web应用","date":"2017-12-02T06:36:34.000Z","updated":"2018-03-13T08:31:58.000Z","comments":true,"path":"2017/12/02/构建web应用/","link":"","permalink":"http://colgin.com/2017/12/02/构建web应用/","excerpt":"构建web应用前面几章介绍了一些Node的基本知识，这里开始介绍如何用Node去构建一个web应用。包括请求的解析，数据上传，路由解析，中间件的知识，这些知识是Node中HTTP模块提供的最基础的功能，同时也是如今众多框架的基础。","text":"构建web应用前面几章介绍了一些Node的基本知识，这里开始介绍如何用Node去构建一个web应用。包括请求的解析，数据上传，路由解析，中间件的知识，这些知识是Node中HTTP模块提供的最基础的功能，同时也是如今众多框架的基础。 12345var http = require('http')http.createServer(function(req,res) &#123; res.writeHead(200,&#123;'Content-Type':'text/plain'&#125;) res.end('Hello world')&#125;).listen(8080) 真实的业务场景还需要大量的工作，但是所有的一切都基于request事件处理函数展开,把最终结果返回一个上面的函数作为参数即可。在具体业务开始前，需要为业务预处理一些细节，这些细节将会挂载上req或者res对象上，供业务代码使用 基础功能请求方法1234567891011121314151617function(req,res) &#123; switch(req.method) &#123; case \"POST\": update(req,res) break' case \"DELETE\": remove(req,res) break' case \"PUT\": create(req,res) break' case \"GET\": default: get(req,res) break' &#125;&#125; 路径解析HTTP_Parser会将请求路径解析为req.url。 需要注意的是客户端代理（浏览器）会将地址解析成报文将路径和查询部分放在报文的第一行。hash部分会被丢弃，不会存在于报文的任何地方。 123456789101112131415//静态文件服务器var url = require('url')function(req,res) &#123; var pathname = url.parse(req.url).pathname fs.readFile(path.join(ROOT,pathname),function(err,file) &#123; if(err) &#123; res.writeHead(400) res.end('找不到相关文件') return &#125; else &#123; res.writeHead(200) res.end(file) &#125; &#125;)&#125; 查询字符串12345678910var url = require('url')var querystring = require('querystring')function(req,res) &#123; var query = querystring.parse(url.parse(req.url).query) /* 也可以通过url.parse()的第二个参数parseQueryString &lt;boolean&gt; 如果为 true，则 query 属性总会通过 querystring 模块的 parse() 方法生成一个对象。 如果为 false，则返回的 URL 对象上的 query 属性会是一个未解析、未解码的字符串。 默认为 false。 var query = url.parse(req.url,true) */ handle(query)&#125; CookieHTTP是一个无状态的歇协议，而真实的业务场景确是需要一定的状态的，否则无法区分用户之间的身份。Cookie的处理分为以下几步 服务器向客户端发送Cookie 浏览器将Cookie保存 之后每次浏览器都会讲Cookie发现服务器 cookie被HTTP_Parser解析到req.header上，可以通过req.headers.cookie访问(key=value;key=value),一般来说在业务逻辑代码执行前，要将转化好的Cookie对象挂载到req对象上，让之后的业务代码可以直接访问 1234function(req,res) &#123; req.cookies = parseCookie(req.header.cookie) handle(req,res)&#125; 服务器通过Set-Cookie字段来写Cookie。写一个完整的cookie字段格式如下Set-Cookie:name=value;Path=/;Expires=Sun,23-Apr-23 22.02.33 GMT;Domain=.domain.com其中name=value是必须的，其他诸多选项用来控制之后浏览器向服务器发送cookie的行为的 123456789101112131415161718192021var serialize = function(name,value,option) &#123; var pairs = [name + &apos;=&apos; + encode(val)]; opt = opt || &#123;&#125; if(opt.maxAge) pairs.push(&apos;Max-Age=&apos; + option.maxage) if(opt.domain) pairs.push(&apos;Domain=&apos; + option.domain) if(opt.path) pairs.push(&apos;Path=&apos; + option.path) if(opt.expires) pairs.push(&apos;Expires=&apos; + option.opt.expires.toUTCString()) if(opt.httpOnly) pairs.push(&apos;HttpOnly&apos;) if(opt.secure) pairs.push(&apos;Secure&apos;) return pairs.join(&apos;;&apos;)&#125;var handle = function(req,res) &#123; if(!req.cookies.isVisit) &#123; res.setHeader(&apos;Set-Cookie&apos;,serialize(&apos;isVisit&apos;,&apos;1&apos;)) res.writeHead(200) res.end(&apos;欢迎你第一次来&apos;) &#125; else &#123; res.writeHead(200) res.end(&apos;欢迎你再次到来&apos;) &#125;&#125; 前端脚本也可以修改Cookie，Cookie在没有过期的时候，之后会随着http请求发送给服务器，如果Cookie太多，会造成浪费。另外如果将Cookie的域设置在根节点，几乎所有的子节点都会带上这些Cookie。而一些静态文件用不着，所以可以为静态文件设置一个不同的域名。或者给cookie设置适当的域。 为静态文件设置不同的域名还有一个好处就是可以突破浏览器下载线程数量的限制，因为域名不同，可以将下载线程数翻倍。但是多一个域名，也会多一次DNS查询 SessionCookie的问题在于容易变得体积过大，而且前后端都可以修改，数据很容易被篡改，其对敏感数据的保护是无效的。Session就是为了解决上述问题而生的，Session数据只保留在服务器端，客户端无法修改，数据安全，而且也无须在协议中每次传递。但是如何将每个客户和服务器中的数据对应起来呢？session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session，用户没访问服务器一次，无论是否该读写session，服务器都认为用户的session活跃了一次。 基于Cookie来实现用户和数据的映射依赖于Cookie,口令放在cookie中。session有效期通常很短，普遍设置为20分钟，如果20分钟内客户端和浏览器没有交互，服务器就把数据删除口令由服务器自动生成。同一机器的两个浏览器窗口 访问服务器时，会生成两个不同的session。但是由浏览器窗口内的链接，脚本打开的新窗口，这类子窗口会共享父窗口的cookie，因此会共享一个session。以下代码中的key值是一个约定的session口令，可以随意约定，connect默认采用connect_id，有的则使用session_id。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//生成sessionvar session = &#123;&#125;//key就是Cookie中session的口令，可以约定var key = 'session_id'var EXPIRES = 20*60*1000var generate = function() &#123; var session = &#123;&#125; session.id = (new Date().getTime() + Math.random()) session.cookie = &#123; expire:(new Date().getTime()) + EXPIRES &#125; sessions[session.id] = session return session&#125;//请求到来时，检查cooke中的口令和服务器端的数据function(req,res) &#123; var id = req.cookie[key] if(!id) &#123; req.session = generate() &#125; else &#123; var session = sessions[id] if(session) &#123; if(session.cookie.expire &gt; (new Date()).getTime()) &#123; //更新超时时间 session.cookie.expire = (new Date()).getTime() + EXPIRES; req.session = session &#125; else &#123; //超时了，删除旧的数据，并重新生成 delete session[id] req.session = generate() &#125; &#125; else &#123; //如果session过期或口令不对，重新生成session req.session = generate() &#125; &#125; handle(req,res)&#125;//响应给客户端时设置新的值，hack响应对象的writeHead()方法，在其内部注入Cookie逻辑var writeHead = res.writeHeadres.writeHead = function() &#123; var cookies = res.getHeader('Set-Cookie') var session = serialize('Set-Cookie',req.session.id) cookies = Array.isArray(cookies) ? cookies.concat(session) : [cookies,session] res.setHeader('Set-Cookie',cookies) return writeHead.apply(this,arguments)&#125;var handle = function(req,res) &#123; if(!req.session.isVisit) &#123; res.session.isVisit = true res.writeHead(200) res.end('欢迎你第一次来') &#125; else &#123; res.writeHead(200) res.end('再次欢迎你') &#125;&#125; 通过查询字符串实现浏览器和服务器端数据的对应检查请求的查询字符串，如果没有值，会先生成新的带值得url12345678910111213141516171819202122232425262728293031323334353637var getURL = function(_url,key,value) &#123; var obj = url.parse(_url,true) obj.query[key] = value return url.format(obj)&#125;//形成跳转，让客户端重新发起请求function(req,res) &#123; var redirct = function(url) &#123; res.setHeader('Location',url) res.writeHead(302) res.end() &#125; var id = req.query[key] if(!id) &#123; var session = generate() redirect(getURL(req.url,key,session.id)) &#125; else &#123; var session = sessions[id] if(session) &#123; if(session.cookie.expire &gt; (new Date()).getTime()) &#123; //更新超时时间 session.cookie.expire = (new Date()).getTime() + EXPIRES; req.session = session handle(req,res) &#125; else &#123; //超时了，删除旧的数据，并重新生成 delete session[id] var session = req.session = generate() redirect(getURL(req.url,key,session.id)) &#125; &#125; else &#123; //如果session过期或口令不对，重新生成session var session = req.session = generate() redirect(getURL(req.url,key,session.id)) &#125; &#125;&#125; 上诉这种方案没有第一种方案好，因为这种使用查询字符串的方式，如果你复制了url给别人，别人就拥有和你一样的身份了。 缓存 添加Expires和Cache-Control到报文头 配置Etags 让Ajax缓存通常来说，POST、DELETE、PUT这类行为性的请求操作不做缓存，大多数缓存只应用在GET请求中。 关于是否可用查询。浏览器如果不能确认这份本地文件可以直接使用，会想服务器发送一次条件请求。有两种方式，时间戳和ETag 时间戳：浏览器会在普通的get请求报文中，附带If-Modified-Since字段。If-Modified-Since:Sun,03 Feb 2013 06:01:22 GMT。服务器如果没有新的版本就会响应304，如果有新版本就发送新版本。并将Last-Modified字段更新。问题在于这种方式只能精确到秒，而且文件时间戳改变了，内容却不定改动。（使用touch命令） ETag：服务端生成，服务端可以决定他的生成规则。一般是内容的散列值。请求响应头是If-None-Match/ETag字段。If-None-Match:”82-1524485454000”,ETag:”82-1524485454000” 上诉两种方式都需要重新请求服务器，可以使用Expires或者Cache-Control字段让浏览器进行缓存，一定条件下可以不用再向服务器请求。Expires会有浏览器和服务器不同步的问题，如服务器提前过期。而Cache-Control可以有效避免这个问题。 使用Expires和Cache-Control字段又叫强缓存，意思就是如果命中缓存将不需要再和服务器进行交互，而使用Etags或者If-Modifie-Since则是弱缓存，需要和浏览器再进行一次交互（条件请求）的叫做协商缓存。强缓存的优先级要高于协商缓存。在强缓存没有命中的情况下才会进行协商缓存（缓存的时间到期了，并不意味着资源资源内容发生改变） 清除缓存当服务器意外更新了资源，又无法通知客户端更新。由于浏览器是根据URL进行缓存，一般解决方案是每次发布，路径中跟随web应用的版本号或者文件内容的hash值。 Basic认证Basic 认证是HTTP 中非常简单的认证方式，因为简单（近乎于明文，一般只有https才会使用），所以不是很安全，不过仍然非常常用。当一个客户端向一个需要认证的HTTP服务器进行数据请求时，如果之前没有认证过，HTTP服务器会返回401状态码，要求客户端输入用户名和密码。用户输入用户名和密码后，用户名和密码会经过BASE64加密附加到请求信息中再次请求HTTP服务器，HTTP服务器会根据请求头携带的认证信息，决定是否认证成功及做出相应的响应。Authorization:Basic dXNlcjpwYXNz12345678910111213141516171819function encode(username,password) &#123; return new Buffer(username + \":\" + password).toString('base64)&#125;funtion(req,res) &#123; var auth = req.headers['authorization'] || '' var parts = auth.split(' ') var method = part[0] || ''//Basic var encoded = part[1] || '' var decoded = new Buffer(encoded,'base64').toString('utf8').split(':') var user = decoded[0] var pass = decoded[1] if(!checkUser(user,pass)) &#123; res.setHeader('WWW-Authenticate','Basic realm=\"Secure Area\"') res.writeHead(401) res.end() &#125; else &#123; handle(req,res) &#125;&#125; 数据上传如果请求中还带有Transfer-Encoding或Content-Length即可判断请求中带有内容 HTTP_Parser解析完请求头之后触发’request’事件，如果有请求体的话，报文内容会通过data事件从触发，我们需要以流的方式处理 1234567891011121314151617var hasBody = function(req) &#123; return('transfer-encoding' in req.headers || 'content-length' in req.headers)&#125;function(req,res) &#123; if(hasBody(req)) &#123; var buffers = [] req.on('data',function(chunk) &#123; buffers.push(chunk) &#125;) req.on('end',function() &#123; req.rawBody = Buffer.concat(buffers).toString() handle(req,res) &#125;) &#125; else &#123; handle(req,res) &#125;&#125; 表单数据请求头Content-Type:application/x-www-form-urlencoded。报文体内容foo=bar&amp;&amp;baz=val123456var handle = function(req,res) &#123; if(req.headers['content-type'] === 'application/x-www-form-urlencoded') &#123; req.body = querystring.parse(req.rawBody) &#125; todo(req,res)&#125; JSON数据请求头Content-Type:application/json。例如:Content-Type:application/json;charset=utf-8 12345678910111213141516var mime = function(req) &#123; var str = req.headers['content-type'] || '' return str.split(';')[0]&#125;var handle = function(req,res) &#123; if(mime(req) === 'application/json') &#123; try &#123; req.body = JSON.parse(req.rawBody) &#125; catch(e) &#123; res.writeHead(400) res.end('Invalid JSON') return; &#125; &#125; todo(req,res)&#125; XML数据请求头Content-Type:application/xml。需要借助库来实现XML数据的解析 文件上传请求头Content-Type:multipart/form-data。例如Content-Type:multipart/form-data;boundary=AaB03xContent-Length:58812。其中boundary是随机生成的一段字符串，指定每部分内容的分界符。报文体的内容通过”··”分割,Content-Length表示报文体长度。以流的方式处理。 数据上传的安全问题在解析表单数据，JSON，XML都是先接收保存数据，然后在解析的。这种方案在数据量大，高并发的情况下容易发生内存耗完的情况。一般有两个解决方案 限制上传文件内容大小，超过限制，停止接收，返回400 通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据12345678910111213141516171819var bytes = 1024function(req,res) &#123; var received = 0 var len = req.headers['content-length'] ? parseInt(req.headers['content-length'],10) : null //内容超过长度限制，返回413 if(len &amp;&amp; len &gt; bytes) &#123; res.writeHead(413) res.end() return &#125; //limit,针对没有Content-Length字段的请求 req.on('data',function(req,res) &#123; received += chunk.length if(received &gt; bytes) &#123; req.destroy() &#125; &#125;) handle(req,res)&#125; 路由解析文件路径型url路径和网站目录一直，无须转换，非常直观。通过url直接请求静态源文件，通过url找到对应脚本，web服务器根据文件后缀去好脚本解析器，并传入http上下文，执行脚本，发出响应。 MVC用户请求的URL和具体脚本所在路径没有任何关系 控制器（Controller）,一组行为的集合 模型（Model），数据相关的操作和封装 视图（View），视图渲染工作模式如下 路径解析，根据URL寻找到对应控制器 行为调用相关模型 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端 URL如何映射到MVC有几种方法：手工映射（正则匹配，参数解析），自然映射 手工映射需要一个路由文件来讲URL映射到对应控制器1234567891011121314151617181920212223//一个处理设置用户信息的控制器exports.setting = function(req,res) &#123; //to do something&#125;//一个将url映射到控制器的函数var routes = []var use = function(path,action) &#123; routes.push([path,action])&#125;function(req,res) &#123; var pathname = url.parse(req.url).pathname for(var i = 0; i &lt; routes.length; i++) &#123; var route = routes[i] if(pathname === route[0]) &#123; var action = route[1] acrion(req,res) return &#125; &#125; handle404(req,res)&#125;use('/user/setting',exports.setting) 而正则匹配就是以正则表达式的形式去匹配路由。参数解析主要是针对url中带有参数的情况，如/profile/:usename,将url中的字段解析成username放到req.params中。 自然映射路由按照一种约定的方式自然而然地实现了路由，而无须去维护路由。路径形式例如/controller/action/param1/param2/param31234567891011121314151617181920function(req,res) &#123; var pathname = url.parse(req,url).pathname var paths = pathname.split('/') var controller = paths[1] || 'index' var action = path[2] || 'index' var args = paths.slice(3) var module try &#123; module = require('./controller/' + controller) &#125; catch (e) &#123; handle500(req,res) return &#125; var method = module[action] if(method) &#123; method.apply(null,[req,res].concat(args)) &#125; else &#123; handle500(req,res) &#125;&#125; RESTfulREST:Representational State Transfer,表现层状态转移。符合REST设计叫做RESTful。设计哲学在于将服务器提供的内容实体看做一个资源，并变现在URL上，对这个资源的操作体现在HTTP请求上（POST,DELETE,PUT,GET增删改查，之前是GET，POST方法传入在URL上传递action）。对于资源的具体变现形态也不同于过去一样表现在URL的后缀上，而是有请求报头的Accept字段和服务器支持情况来决定。如Accept:application/json,application/xml。服务器可以根据这个字段做出响应，并且在响应报文中的Content-Type字段中告知。总之就是通过URL设计资源、请求方法定义资源操作，通过Accept决定资源的表现形式。 中间件使用中间件来隔离基础设施与业务逻辑中间的细节，让开发者能够关注在业务的开发上。由于Node异步运行机制的问题，需要一种机制来实现，在当前中间件处理完成后，通知下一个中间件执行。（例如尾触发） 12345678910111213141516171819//querystring解析中间件var querystring = function(req,res,next) &#123; req.query = url.parse(req.url,true) next()&#125;//cookie解析中间件var cookie = function(req,res,next) &#123; var cookie = req.heders.cookie var cookies = &#123;&#125; if(cookie) &#123; var list = cookie.split(';') for(var i = 0; i &lt; list.length; i++) &#123; var pair = list[i].split('=') cookies[pair[0].trim()] = pair[1] &#125; &#125; req.cookies = cookies next()&#125; 可以使用app.use()来将中间件都存进stack数组中保存，等待匹配后触发执行。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var routes = &#123;'all':[]&#125;var app = &#123;&#125;app.use = function(path) &#123; var handle if(typeof path === 'string')&#123; handle = &#123; //第一个参数作为路径 path:pathRegexp(path) //将中间件存进stack数组 stack:Array.prototype.slice.call(arguments,1) &#125; &#125; else &#123; handle = &#123; path:pathRegexp('/') stack:Array.prototype.slice.call(arguments,1) &#125; &#125; routes.all.push(handle)&#125;//匹配函数var match = function(pathname,routes) &#123; var stacks = [] for(var i = 0; i &lt; routes.length; i++) &#123; var route = routes[i] var reg = route.path.regexp var matched = reg.exec(pathname) if(matched) &#123; stacks = stacks.concat(route.stack) &#125; &#125; return stacks&#125;function(req,res) &#123; var pathname = url.parse(req.url).pathname var method = req.method.toLowerCase() //获取all()方法里的中间件 var stacks = match(pathname,routes.all) if(routes.hasOwnPropery(method)) &#123; //根据请求方法，获取相关中间件 stacks.concat(match(pathname,routes[method])) &#125; if(stacks.length) &#123; handle(req,res,stacks) &#125; else &#123; handle404(req,res) &#125;&#125; 异常处理12345678910111213141516var handle = function(req,res,stack) &#123; var next = function(err) &#123; if(err) &#123; return handle500(err,req,res,stack) &#125; //从stack数组中取出中间件并执行 var middleware = stack.shift() if(middleware) &#123; try &#123; middleware(req,res,next) &#125; catch(e) &#123; next(e) &#125; &#125; &#125;&#125; 页面渲染内容响应响应报头Content-Encoding、Content-Length、Content-Type。浏览器会根据响应头的Content-Type采用不同的而处理方式。Content-Type的值也叫MIME（Multipurpose Internet Mail Extensions）值。不同的文件类型有不同的MIME值。附件下载：无论响应内容什么样的MIME值，都不需要客户端打开它，只需要弹出并下载它即可。可以使用Content-Disposition字段。这个字段影响的行为是客户端会根据这个值判断是应该将报文数据当做即时浏览的内容（inline），还是可以下载的附件（attachment）。Content-Disposition:attachment;filename=”filename.txt”12345678res.sendfile = function(filepath) &#123; fs.stat(filepath,function(err,stat) &#123; var stream = fs.createReadStream(filepath) res.setHeader('Content-Type',mime.lookup(filepath)) res.setHeader('Content-Length',stat.size) res.setHeader('Content-Disposition',\"attachment\" + filename + path.basename()) &#125;)&#125; 模板模板实现的其实就是字符串的拼接","categories":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"},{"name":"Web","slug":"Web","permalink":"http://colgin.com/tags/Web/"}]},{"title":"NodeJS测试","slug":"NodeJS测试","date":"2017-11-29T08:46:29.000Z","updated":"2017-11-29T08:46:28.000Z","comments":true,"path":"2017/11/29/NodeJS测试/","link":"","permalink":"http://colgin.com/2017/11/29/NodeJS测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Node中的网络编程","slug":"Node中的网络编程","date":"2017-11-25T11:15:40.000Z","updated":"2018-03-11T09:25:56.000Z","comments":true,"path":"2017/11/25/Node中的网络编程/","link":"","permalink":"http://colgin.com/2017/11/25/Node中的网络编程/","excerpt":"在web领域，大多数编程语言需要专门的web服务器作为容器，如ASP、ASP.NET需要IIS作为服务器，PHP需要搭载Apache或Nginx环境，JSP需要Tomcat服务器等，但是Node只需要几行代码就可以构建服务器，无需额外的容器。Node提供net、dgram、http、https分别处理TCP、UDP、HTTP、HTTPS，适用于服务端和客户端。","text":"在web领域，大多数编程语言需要专门的web服务器作为容器，如ASP、ASP.NET需要IIS作为服务器，PHP需要搭载Apache或Nginx环境，JSP需要Tomcat服务器等，但是Node只需要几行代码就可以构建服务器，无需额外的容器。Node提供net、dgram、http、https分别处理TCP、UDP、HTTP、HTTPS，适用于服务端和客户端。 构建TCP服务TCP中连接一旦建立，所有的回话都基于连接完成，客户端如果想和另一个TCP服务器通信，需要另外创建一个套接字来连接1234567891011121314//服务端var net = require('net')var server = net.createServer(function(socket) &#123; socket.on('data',function(data) &#123; socket.write('hello') &#125;) socket.on('end',function() &#123; console.log('连接断开') &#125;) socket.write('welcome')&#125;)server.listen(8124,function() &#123; console.log('server is running')&#125;) 123456789101112//客户端var net = require('net')var client = net.connect(&#123;port:8124&#125;,function() &#123; console.log('client connected')&#125;)client.on('data',function(data) &#123; console.log(data.toString()) client.end()&#125;)client.on('end',function() &#123; console.log('client disconnected')&#125;) 服务器可以同时和多个客户端保持连接，每个连接都是可读可写的Stream对象。另外需要注意的是TCP针对网络中的小数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中只有极少数有效数据的数据包，将十分浪费网络资源，Nagle算法针对这种情况，要求缓冲区的数据达到一定数据或者一定时间后才将其发出。所以小数据包会被Nagle算法合并，以此优化网络，这种优化虽然使得网络宽带被有效地利用，但是数据有可能被延迟发送。在Node中，TCP默认开启Nagle算法，可以通过socket.setNoDelay(true)去掉Nagle算法，使得write()可以立即发送数据到网络中。尽管在网络的一端调用write()会调用另一端的data事件，但是并不是意味着每次write()都会触发data事件，在关掉Nagle算法后，另一端肯能会将接收到多个小数据包合并，然后值触发一次data事件。 构建UDP服务UDP中一个套接字可以与多个UDP服务通信。1234567891011//服务器var dgram = require('dagram')var server = dgram.createSocket('udp4');server.on('message',function(msg,rinfo) &#123; console.log('server got: ' + msg + rinfo.address + ':' + rinfo.port) &#125;)server.on('listening',function() &#123; var address = server.address() console.log('server listening' + address.address + ':' + address.port)&#125;)server.bind(41234) 1234567//客户端var dgram = require(&apos;dgram&apos;)var messge = new Buffer(&apos;hello world&apos;)var client = dgram.createSocket(&apos;udp4&apos;)client.send(message,0,message.length,41234,&apos;localhost&apos;,function(err,bytes) &#123; client.close()&#125;) 构建HTTP服务应用层协议，是对TCP的高级封装。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块是将connection到request进行了封装。http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象。在请求过程中个，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完成请求报文之后，触发request事件，调用用户逻辑。 HTTP请求请求报文体部分抽象为一个只读流对象，如果业务逻辑需要读取报文中的数据流结束之后才能进行操作1234567891011function(req,res) &#123; var buffers = [] req.on('data',function(chunk) &#123; buffers.push(chunk) &#125;) req.on('end',function() &#123; var buffer = Buffer.concat(buffers) //业务逻辑 res.end('hello world') &#125;)&#125; http响应它封装了对底层连接的写操作，可以看做是一个可写的流对象。可以用res.setHeader()和res.writeHead()来设置头信息。在实际应用中，我们可以多次调用setHeader()进行设置，但只有调用writeHeader()后，报头才会写入连接中。报文体部分则是通过调用res.write()和res.end()方法实现。后者和前者的差别在于res.end()会先调用write()发送数据，然后发送信号告知服务器这次响应结束。需要注意的是无论服务器端处理业务时是否发生异常，务必在结束时调用res.end()结束请求，否则客户端将一直处于等待状态（pending）。当然也可以通过延迟res.end()来实现客户端和服务端之间的长连接，但结束时务必关闭连接。 HTTP服务器事件 connection事件:在开始HTTP请求之前，客户端与服务器需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多个请求响应之间使用，当这个连接建立时，服务器就触发了一次connection事件 request事件:建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；res.end()后，TCP连接可能用于下一次请求响应 HTTP代理在TCP keep-alive的情况下，一个底层连接可以多次用于请求。http模块包含了一个默认的客户端代理对象http.globalAgent。通过ClientRequest对象对同一个服务器端发起的HTTP请求时，最多可以创建5个连接。如果HTTP客户端同时对一个服务器发起10次HTTP请求，实质上只有5个请求处于并发状态，后续请求需要等待某个请求完成服务后才真正发出。可以通过设置agent:false。脱离连接池管理，使得请求不受并发限制。 构建websocket服务websocket相对于HTTP有以下好处 客户端和服务端只需要建立一个TCP连接，可以使用更少的连接 websocket服务端可以推送数据到客户端，远比HTTP请求响应模式更灵活，更高效。之前是用长轮询的技术实现服务器推送。 有更轻量的头，减少数据传送量另外需要注意的是websocket的握手部分是有HTTP完成的websocket握手 网络服务与安全Node在网络安全上提供给了三个模块，crypto、tls、https。其中crypto主要用于加密解密，sha1、md5等加密算法都有。tls模块归功了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全和http模块一致，区别在于它建立在安全的连接之上。 TLS/SSLSSL是NetScape提出的安全协议(Secure Sockets Layer 安全套接层)。TLS是IETF的标准化实现(Transport Layer Security安全传输层协议)。 密钥TLS/SSL是一个公钥/私钥的结构，他是一个非对称的结构，每个服务器和客户端都有自己的公钥和私钥。公钥用来加密要传输的数据，私钥用来解密收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全的传输之前，客户端和服务端之间要互换公钥。客户端发送数据时要通过服务器的公钥进行加密，服务器发送数据时需要通过客户端的公钥进行加密。这样就可以完成加密解密的过程。但是这样仍然存在窃听的情况，比如说中间人攻击。客户端和服务端在交换公钥过程中，中间人对客户端扮演服务器的角色，对服务器扮演客户端的角色，因此客户端和服务端都感受不到中间人的存在。而为了解决这个问题，TLS/SSL引入了数字证书来进行验证。 数字证书与直接交换公钥不同，数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称，来自签名颁发机构的签名，在连接之前，会通过证书中的签名确认收到的公钥是来自目标服务器，从而产生信任关系。CA(Certificate Authority)为站点颁发证书，这个证书具有CA通过自己的公钥和私钥实现的签名。服务器需要通过自己的私钥生成CSR(Certificate Signing Request,证书签名请求)文件，CA机构将通过这个文件颁发属于该服务器的签名证书，只要从国CA机构就能验证证书是否合法。","categories":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"},{"name":"网络编程","slug":"网络编程","permalink":"http://colgin.com/tags/网络编程/"},{"name":"安全加密","slug":"安全加密","permalink":"http://colgin.com/tags/安全加密/"}]},{"title":"Node中的Buffer","slug":"Node中的Buffer","date":"2017-11-24T13:04:55.000Z","updated":"2018-03-11T07:01:02.000Z","comments":true,"path":"2017/11/24/Node中的Buffer/","link":"","permalink":"http://colgin.com/2017/11/24/Node中的Buffer/","excerpt":"Node不同于前端JavaScript，在前端只需做一些简单的字符串和DOM操作即可。而在后端，需要处理大量的图片，文件，以及操作数据库。需要处理大量的二进制数据，Buffer也就应运而生了。","text":"Node不同于前端JavaScript，在前端只需做一些简单的字符串和DOM操作即可。而在后端，需要处理大量的图片，文件，以及操作数据库。需要处理大量的二进制数据，Buffer也就应运而生了。 Buffer结构模块结构Buffer模块性能部分由c++实现，而非性能的相关部分使用JavaScript实现。Buffer对象属于堆外内存，不是由V8分配的。Buffer在Node进程启动时就已经加载进来了，所以无需require Buffer对象Buffer对象类似于数组，它的每一项是16进制的两位数（0-255），可以通过length属性访问Buffer对象的长度（返回字节数）。同时也可以像数组一样给Buffer对象的某一位赋值（取值） Buffer的内存分配在c++层面申请内存，在JavaScript中分配内存。而为了高效的使用分配来的内存,Node使用slab机制（一种动态内存管理机制），slab就是一块申请好的固定大小的内存区域。Node以8kb来区分Buffer对象是大对象还是小对象。Buffer.poolSize = 8 * 1024。8kb也是每个slab的大小 分配小对象构建小对象的Buffer对象时，会去看当前处于分配的slab空间是否足够，如果够就把Buffer对象放进slab中，并且用Buffer对象的parent属性指向该slab，用offset来标记相对于slab的偏移。如果不够就构造一个新的slab。一个slab可能会分配给多个Buffer对象使用，只有这些对象在作用域内释放并都可以回收，slab的空间才会回收。 分配大对象如果需要构建超过8kb的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个SlowBuffer对象呗这个大Buffer对象独占。 Buffer转换Buffer对象可以和字符串实现相互转换，但是要注意编码问题。对于不支持的编码可以通过第三方库来支持，比如iconv-lite Buffer拼接123456789var fs = require('fs')var rs = fs.createReadStream('test.md')var data = \"\"rs.on('data',function(chunk) &#123; data += chunk&#125;)rs.on('end',function() &#123; console.log(data)&#125;) 需要注意的是data事件中的chunk就是Buffer对象。而data += chunk这句代码里隐藏了toString()操作，它其实等价于data = data.toString() + chunk.toString()。这在英文中是没有问题的，但是在中文的环境下可能就会有问题。因为中文是宽字节编码。1var rs = fs.createReadStream(\"test.md\",&#123;highWaterMark:11&#125;) 上诉代码如果test.md中是中文的话，就会出现乱码问题。这里设置每次读取的Buffer长度为11个字节，但是每个中文字占有3个字节，多出来的就会显示为乱码。 可以通过设置编码来解决这个问题12var rs = fs.createReadStream(&apos;text.md&apos;,&#123;highWaterMark:11&#125;)rs.setEncoding(&apos;utf8&apos;) 上诉代码输出不会出现乱码。原因是内部通过decoder对象来实现。data事件不再接收原始的Buffer对象，而是一个decoder对象，这个对象会把多出来的字节放到下一个对象上去。但是他只能处理utf8，base64和ucs-2/utf-16le三种编码。更好的解决方案是用一个数组接收所有的buffer片段，最后合并成一个Buffer对象，然后转换成字符串123456789101112var chunks = []var size = 0res.on('data',function(chunk) &#123; chunks.push(chunk) size += chunk.length&#125;)res.on('end',function() &#123; var buf = Buffer.concat(chunks,size) var str = buf.toString('utf8') console.log(str)&#125;) Buffer与性能Buffer在文件I/O和网络I/O运用广泛。在应用中通常会操作字符串，但是在网络传输过程中，都需要转换为Buffer，以二进制数据传输。12345678910var http = require('http')var helloworld = \"\"for(var i = 0; i &lt; 1024*10; i++) &#123; helloworld += 'a'&#125;//helloworld = new Buffer(helloworld)http.createServer(function(req,res) &#123; res.writeHead(200) res.end(helloworld)&#125;).listen(8080) 上诉代码构造了一个10kb的字符串，然后发送给请求的客户端。实验可以证明将helloworld从字符串转化为Buffer对象性能好些。原因在于网络传输的是二进制，提前转化就无需每次请求都要转换一下。在文件读取的时候hightWaterMark参数的设置也格外重要。越大性能越好。（新版Node去掉了这个属性）","categories":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"}]},{"title":"Node中的内存控制","slug":"Node中的内存控制","date":"2017-11-24T02:49:29.000Z","updated":"2017-11-24T12:21:06.000Z","comments":true,"path":"2017/11/24/Node中的内存控制/","link":"","permalink":"http://colgin.com/2017/11/24/Node中的内存控制/","excerpt":"V8V8的内存限制在Node中通过JavaScript使用内存会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB）。这种限制下，会导致Node无法直接操作大内存对象。造成这种限制的主要原因在于Node基于V8构建，所以在Node中使用JavaScript对象都是通过V8自己的方式来进行分配和管理的。","text":"V8V8的内存限制在Node中通过JavaScript使用内存会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB）。这种限制下，会导致Node无法直接操作大内存对象。造成这种限制的主要原因在于Node基于V8构建，所以在Node中使用JavaScript对象都是通过V8自己的方式来进行分配和管理的。V8做这种限制的原因在于两点，其一，v8最初是设计给浏览器使用，浏览器上不大会遇到大内存的情况，所以限制值就足够使用了；其二，受限于V8的垃圾回收机制，按照官方说法，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的事件，在这样的时间花销下，应用的性能和响应能力都会直线下降。这就限制了开发者随心所欲使用大内存的想法。如果超过了这个限制，可能会导致进程退出。 v8的对象分配在V8中，所有JavaScript对象都是通过堆来进行分配的，可以通过process.memoryUsage()来查看 V8的垃圾回收机制内存分代在V8中，把内存分为新生代和老生代两种，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。从V8源码中可以看到，默认设置下，老生代内存在64位系统下为1400MB，在32位系统下为700MB。新生代内存由两个reserved_semispace_size_构成，reserved_semispace_size_在64位和32位系统下分别是16MB和8MB，所以新生代内存在64位和32位系统下分别为32MB和16MB。V8堆内存的最大保留空间公式为：4*reserved_semispace_size_ + max_old_generation_size_。所以准确的说v8堆内存在64位和32位系统下的大小为1464MB和732MB 内存回收算法Scavenge算法：空间换时间，适用于新生代内存采用Cheney算法，使用负值的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被赋值到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。（注意只复制存活的对象，由于新生代中对象生命周期比较短，所以这种算法有优异的表现）。在一定条件下，需要将存活周期长的对象移动到老生代中去（对象晋升），条件如下（满足一个即可） 对象是否经历过Scavenge回收 To空间的内存占用比例是否超过限制（25%） Mark-Sweep &amp; Mark—Compact：适用于老生代内存Mark-Sweep：标记清除，在标记阶段遍历堆中所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。（死对象在老生代中只占较小部分）Mark-Compact：标记整理，是为了解决Mark-Sweep算法清理之后内存不连续的情况，是在Mark-Sweep的基础上演变而来。差别在于对象在标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。要不断移动对象，执行速度不快。所以V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才会使用Mark-Compact。 高效使用内存函数作用域释放后（函数执行完），作用域内的局部变量也会在下次垃圾回收中被释放。如果变量是全局变量（不通过var声明或定义在global变量上），由于全局作用域需要等到进程退出才能释放此时将导致引用的对象常驻内存（老生代中），如果需要释放常驻内存的对象，可以通过delete操作来删除引用关系。或者将变量重新复制，让旧对象脱离引用关系，在接下来的老生代内存清除和整理的过程中会被回收释放。1234global.foo = 'an object'delete global.foo//或者重新赋值global.foo = undefined//or null 一般来说在V8中通过重新赋值的方式解除引用比较好一点，因为通过delete删除对象属性有可能干扰V8的优化。需要注意的是闭包导致原始作用域不能得到释放而导致内存占用不会得到释放。 内存指标查看进程的内存占用：process.memoryUsage()rss(resident set size):进程的常驻内存heapTotal:堆中总共申请的内存量heapUsed：目前堆中使用中的内存量（字节） 查看系统的内存占用 os.totalmem()：返回操作系统的总内存 os.freemem()：返回操作系统的闲置内存堆外内存可以通过process.memoryUsage()可以看到堆中的内存用量总是小鱼进程的常驻内存用量，这意味着Node中的内存使用并非都是通过V8进行分配的。将那些不是通过V8分配的内存称为堆外内存。比如Buffer对象就不经过V8的内存分配机制，所以它不会有堆内存的大小限制 大内存应用在Node中不可避免的会存在操作大文件的情况，但是由于Node的内存限制，操作大文件要格外注意。不过Node提供了stream模块用于处理文件。stream是Node原生模块，直接应用即可。由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接来进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法可以通过流的方式对大文件进行操作。","categories":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"}]},{"title":"你真的了解JavaScript中的异步吗","slug":"你真的了解JavaScript中的异步吗","date":"2017-11-22T09:06:25.000Z","updated":"2020-06-07T02:17:29.187Z","comments":true,"path":"2017/11/22/你真的了解JavaScript中的异步吗/","link":"","permalink":"http://colgin.com/2017/11/22/你真的了解JavaScript中的异步吗/","excerpt":"异步初探setTimeout和setInterval如果把setInterval的事时间设置为0，cpu就会频繁运行吗？答案是否定的，实验证明，浏览器上大约200次/秒，Node环境下，大约为1000次/秒。然而，如果是while循环的话，浏览器上大约触发频率是400万次/秒，Node环境下会达到400万次/秒。这是因为HTML规范推行的时延/间隔最小值是4毫秒。另外需要注意的是setTimeout和setInterval异步执行也会导致其定时精度不高。","text":"异步初探setTimeout和setInterval如果把setInterval的事时间设置为0，cpu就会频繁运行吗？答案是否定的，实验证明，浏览器上大约200次/秒，Node环境下，大约为1000次/秒。然而，如果是while循环的话，浏览器上大约触发频率是400万次/秒，Node环境下会达到400万次/秒。这是因为HTML规范推行的时延/间隔最小值是4毫秒。另外需要注意的是setTimeout和setInterval异步执行也会导致其定时精度不高。123456var start = new DatesetTimeout(function()&#123; var end = new Date console.log(end - start)&#125;,500)while(new Date - start &lt; 1000)&#123;&#125; 上诉代码原本想要500毫秒之后执行函数的，然而由于setTimout和setInterval的异步特性，需要等到JavaScript代码执行完之后才能执行，所以这里会在while循环出卡住1000毫秒 由于setTimeout和setInterval的不精确性，更高精度的计时方案是 process.nextTick() requestAnimationFrame():60帧/秒 和异步一起谈到的是非阻塞。非阻塞强调了Node的高速度。举个例子，异步MySql数据库驱动程序做一个查询可能要一个小时，但是负责发送查询请求的那个函数却能以微秒级速度返回。这对于那些需要快速处理海量需求的场景来说就很棒。 事件PubSub模式1234567891011121314PubSub = &#123;handlers:&#123;&#125;&#125;PubSub.on = function(eventType, handler) &#123; if(!(eventType in this.handlers)) &#123; this.handlers[eventType] = 1 &#125; this.handlers[eventType].push(handler)&#125;PubSub.emit = function(eventType) &#123; var handlerArgs = Array.prototype.slice.call(argument,1) for(var i = 0; i &lt; this.handlers[eventType].length; i++) &#123; this.handlers[eventType][i].apply(this,handlerArgs) &#125;&#125; Promise/Deferred对象 jQuery中的Promise/Deferred:Promise接收三种回调形式：done、fail、和progress。执行Promise对象时，运行的是done回调；拒绝Promise对象时，运行的是fail回调；对处于挂起状态的Deferred对象调用notify时，运行的是progress回调。1234567891011121314151617var nanowrimoing = $.Deferred();var wordGoal = 5000;nanowrimoing.progress(function(wordCount) &#123; var percentComplete = Math.floor(wordCount / wordGoal * 100) $('#indicator').text(percentComplete + '% complete')&#125;)nanowrimoing.done(function() &#123; $('#indicator').text('Good job!')&#125;)//对数字变化进行响应$('document').on('keypress',function() &#123; var wordCount = $(this).val().split(/s+/).length if(wordCount &gt;= wordGoal) &#123; nanowrimoing.resolve() &#125; nanowrimoing.notify(wordCount)&#125;) 准确的说，Deferred是Promise的超集，他比Promise多了一项关键特性：它可以直接使用resolve（执行）和reject（拒绝）来直接触发Deferred对象。纯Promise实例只允许添加多个调用，而且必须由其他什么东西来触发这些调用。 可以通过Deferred对象的promise()方法来生成一个Promise对象，需要注意的是生成的Promise对象只是原Deferred对象一个没有方法的副本。回调绑定在Deferred或者其下辖的Promise对象并无区别。每个Deferred对象都含有一个Promise对象，而每个Promise对象都代表一个Deferred对象。有了Deferred对象，就可以控制其状态，而有了纯Promise对象那个，只能读取其状态及附加回调。12var prompDeferred = new $.Deferred()var prompPromise = prompDeferred.promise() 理想情况下，所有的异步操作都应该返回Promise对象，但是大多数JavaScript API（浏览器或者Node)都是基于回调函数，而不是Promise对象。在基于回调函数的API中使用Promise对象最直接的方法就是生成一个Deferred对象并传递其触发器函数作为API的回调函数。12345678var fileReading = new $.Deferred()fs.readFile(filename,'utf8',function(err) &#123; if(err) &#123; fileReading.reject(err) &#125; else &#123; fileReading.resolve(Array.prototype.slice.call(arguments,1)) &#125;&#125;) worker对象的多线程多线程技术会有状态共享的难题，但是多线程又能充分利用多颗CPU内核。可以将worker理解为：应用程序的主线程对worker说，去，开一个单独的线程来运行这段代码。worker可以给主线程发送消息（反之亦可），其表现形式是事件队列中运行的回调。简而言之，与不同线程进行交互的方式在于JavaScript中进行I/O操作一模一样。 在操作系统层面：线程和进程有着巨大的区别，同一个进程内的多个线程可以分享状态，而彼此独立的进程之间则不能。 网页版的worker对象（HTML5）12345678910111213//主脚本var worder = new Worker('boknows.js')worker.addEventListener('message',function(e) &#123; console.log(e.data)&#125;)//向worker发送数据worker.postMessage('football')//boknows.jsself.addEventListener('message',function(e) &#123; //向主线程发送数据 self.postMessage(e.data)&#125;) 网页版的worker目标是在不损害DOM响应能力的前提下处理复杂的计算。可以用在解码视频，加密通信，解析网页式编辑器中的文本。通常情况下，worker对象会把自己的计算结果发送给主线程，由主线程去更新页面，为什么不直接更新页面呢？这里主要是为了保护JavaScript异步抽象概念。如果worker对象可以改变页面的标记语言，那么最终下场就会和java一样–必须将DOM操控代码封装成互斥量和信号量来避免竞态条件。 Node版的worker：clusterNode版的worker对象有cluster.fork()把运行自己的同一个脚本再次加载成一个独立的进程（可以通过cluster.isMaster来检测自己是主进程还是worker对象）,目的在于Node服务器要留出计算资源以保障其主要任务：处理请求。网页版本worker对象会加载一个独立的脚本。123456789101112131415var cluster = require('cluster')if(cluster.isMaster) &#123; //分化出worker对象 var coreCount = require('os').cpus().length for(var i = 0; i &lt; coreCount; i++) &#123; cluster.fork() &#125; //绑定death事件 cluster.on('death',function(worker) &#123; console.log('Worker' + worker.pid + 'has died') &#125;)&#125; else &#123; //立即死去 process.exit()&#125; 异步脚本加载script标签 放在head里：如果在head标签里放了大脚本会滞压所有页面的渲染工作，使得用户在脚本加载完毕之前一直处于‘白屏死机‘状态。、 放在body标签末尾：如果放的是大脚本，会让用户看到毫无生命力的静态页面，原本应该进行客户端渲染的地方却散步者不起作用的空间和空空如也的方框。另外就算不是大教本，这种方式使得浏览器在加载完整个文档之前无法加载这些脚本，这对于那些通过慢速连接传送的大型文档来说是一个瓶颈。 所以这里要对不同性质的脚本分而治之，那些负责让页面更好看，更好用的脚本应该立即加载，而那些可以待会再加载的脚本可以稍后再加载（async/defer） 脚本的三种加载方式同步加载（阻塞型）脚本的获取和执行是同步的。在此过程中个页面被阻塞，停止解析。但这样如果js中有输出document内容、修改dom、重定向等行为，就会造成页面堵塞。所以一般建议把标签放在结尾处，这样尽可能减少页面阻塞。 延迟加载（defer）脚本的获取是异步的，执行时同步的。脚本加载不阻塞页面解析，脚本在获取完之后并不立即执行，而是等到DOMready之后才开始执行。延迟加载就是为了解决这个问题，将JS切分成许多模块，页面初始化时只加载需要立即执行的JS，然后其它JS的加载延迟到第一次需要用到的时候再加载，类似图片的延迟加载。 异步脚本（async）脚本的获取是异步的，执行是同步的。和defer的不同点在于脚本获取之后会立即执行，这就会造成脚本的执行顺序和页面上脚本的排放顺序不一样，可能会造成脚本依赖问题","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"http://colgin.com/tags/异步/"}]},{"title":"异步编程","slug":"异步编程","date":"2017-11-18T08:11:41.000Z","updated":"2019-06-30T03:27:00.767Z","comments":true,"path":"2017/11/18/异步编程/","link":"","permalink":"http://colgin.com/2017/11/18/异步编程/","excerpt":"函数式编程 高阶函数：JavaScript中函数式一等公民，可以作为参数传递，或者作为返回值返回 偏函数：指创建一个调用另一个部分-参数或变量已经预置的函数-的函数的用法","text":"函数式编程 高阶函数：JavaScript中函数式一等公民，可以作为参数传递，或者作为返回值返回 偏函数：指创建一个调用另一个部分-参数或变量已经预置的函数-的函数的用法 12345var isType = function(type) &#123; return function(obj) &#123; return Object.prototype.toString.call(obj) === ['Object' + type] &#125;&#125; 由上诉代码可知，这种通过指定部分参数来产生一个新的定制函数的形式就是偏函数。这样就不用挨个去实现isFunction()、isString()这样的函数，只需要在isType函数传入参数即可得到定制函数 异步编程的优势和难点优势利用事件循环的方式，JavaScript线程像一个分配任务和处理结果的大管家，I/O线程池里的各个I/O线程都是小二，负责兢兢业业地完成分配来的工作，小二与管家互不依赖，所以可以保持整体的高效率。这个模型的缺点在于管家无法承担过多的细节性任务，如果承担过多，则会影响到任务的分配和调度，管家忙个不停，小二却没有活干，这样效率就会降低。Node是为了解决编程模型中阻塞I/O的性能问题的，采用了单线程模型，这导致Node更新一个处理I/O密集问题的能手，cpu密集型则取决于管家能耐。由于海量请求同时作用在单线程上，需要防止任何计算耗费过多的cpu时间片。所以无论是I/O密集型还是计算密集型，只要计算不影响异步I/O的调度，都不会有问题。所以可以将海量计算分解为诸多小量计算，通过setImmediate()进行调度。 难点 异常处理:不能像同步代码那样使用try…catch，因为异步I/O分为两步，提交请求，和处理结果。try…catch只能捕获提交请求这个阶段的错误（只能捕捉当前这个事件循环的错误），因为处理结果（回调函数的执行）是在下一个事件循环才会执行，try…catch捕捉不到callback执行时抛出的异常。 在Node中，我们在处理异常时形成了一种规定，会将异常放在回调的一个实参传递，如果不为空，则说明有异常。 函数嵌套过深：多个异步调用 多线程编程：单线程无法高效利用多核cpu的服务器，因为单个Node进程实质上没有充分利用多核cpu。web workers。 异步编程解决方案事件发布/订阅模式依赖于Node自身提供的event模块，回调函数事件化。Node对事件的发布订阅机制做了一些小的限制。比如说对一个事件添加的侦听器不能超过10个（这个限制也可以自己修改）为了防止内存泄漏以及过多占用cpu Promise/Deferred模式这种模式可以先执行异步调用，延迟传递处理函数。这种方式比预先传入回调更好看一些。在原始API里一个事件只能处理一个回调，而通过deferred对象，可以对事件加入任意的业务处理逻辑。CommonJS的Promise/A就是这种模式的一种实现。 1234$.get('/api) .success(onSuccess) .error(onErroe) .complete(onComplete) 流程控制async async.series()：异步的串行执行 async.parallel()：异步的并行执行 async.waterfall()：异步调用的依赖处理","categories":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"}]},{"title":"NodeJS异步IO","slug":"NodeJS异步IO","date":"2017-11-17T03:37:16.000Z","updated":"2018-03-10T08:33:52.000Z","comments":true,"path":"2017/11/17/NodeJS异步IO/","link":"","permalink":"http://colgin.com/2017/11/17/NodeJS异步IO/","excerpt":"提到Node，我们很容易想到异步IO，但是什么是异步IO？为什么要用异步IO？异步IO执行流程是怎么样的？你真的了解Node中的异步IO吗？","text":"提到Node，我们很容易想到异步IO，但是什么是异步IO？为什么要用异步IO？异步IO执行流程是怎么样的？你真的了解Node中的异步IO吗？ 导读异步IO其实并不是一个新鲜的概念，它早就存在于操作系统中，但是由于使用异步的编程模式不太好理解，以至于一些高级语言典型如PHP，在语言层面屏蔽了异步甚至是多线程，PHP是以同步阻塞的方式来运行的，这种设计的优点在于，程序员同步编写代码，代码很好理解。缺点在于阻塞导致其不能很好的并发。Node的设计理念是事件驱动，异步I/O。 为什么需要异步I/O用户体验首先我们要知道的是浏览器中的JavaScript是在单线程上执行，而且它还是与UI渲染共用一个线程。这就意味着JavaScript在执行过程的时候UI渲染和响应处于停滞状态（所以脚本执行时间不能过长）。需要注意的是B/S模型总，网络速度会给用户体验带来很大麻烦。如果以同步方式获取服务器上的资源，JavaScript会停住等待，这期间UI会停顿，交互不能响应。 同步和异步运行时间比较1234567//同步方式运行，总共耗时M+NgetDate(url1) //耗时MgetDate(url2) //耗时N//异步方式运行，总共耗时max(M,N)getDate(url1,function(result) &#123;&#125;)//耗时MgetDate(url2,function(result) &#123;&#125;)//耗时N 资源分配 需要了解的是，如果有一组互不相关的任务需要完成，主流的方法有两个，单线程串行执行和多线程并行的区别。多线程的代价在于执行期线程上下文切换开销比较大。在业务复杂的时候，还经常面临锁，状态同步的问题。优点在于在多核cpu上能够有效提升cpu利用率。单线程优点在于编程方式比较符合人的思维习惯，易于表达。缺点在于其性能不是很好，一个略慢的任务会导致后续执行代码被阻塞。在计算机资源中，通常I/O与CPU计算之间是可以并行进行的。但是同步编程却使得I/O操作让后续任务等待，造成资源不能很好的利用。 Node在单线程同步和多线程并行之间选择的方案是：利用单线程，远离死锁，状态同步的问题，利用异步，远离单线程阻塞的问题，更好利用cpu。 另外Node为了弥补单线程无法利用多核CPU的缺点，也提供了类似前端web workers的子进程。该子进程可以通过工作进程高效利用CPU和I/O。 异步I/O与非阻塞I/O异步I/O ≠ 非阻塞I/O同步/异步和阻塞/非阻塞是两回事。对操作系统内核I/O来说，只有阻塞I/O和非阻塞I/O。 阻塞I/O：调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。以读文件为例，磁盘寻道，读取数据，复制数据到内存中，调用结束 非阻塞I/O：调用之后立即返回，返回的不是业务层期望的数据，而是当前调用的状态，如果要获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。（重复确认-&gt;轮询），其麻烦的地方在于需要采用轮询技术去确认是否完成数据获取。cpu判断，耗费cpu资源。轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于应用程序来说，这只能算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧会需要很多时间来等待。理想情况下的非阻塞异步I/O应该是应用程序发起非阻塞调用，无需通过遍历或者时间唤醒等待方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或者回调将数据传递给应用程序即可。 现实的异步I/O通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让另一个线程进行计算处理，通过线程之间的通信将I/O得到得数据进行传递，这种便是典型的线程池模拟异步I/O。典型的*nix下的libeio和windows下的IOCP都是使用这种方式，而Node提供了libuv作为抽象封装层，使得Node支持跨平台异步I/O。 需要注意的是，我们常说Node是单线程的，指的是JavaScript执行在单线程中，在Node中，无论在什么平台，内部完成I/O任务都另有线程池。除了用户代码无法并行执行外，所有的I/O则是可以并行起来的 Node中的异步I/O事件循环（event loop）整个Node执行都在一个事件循环中 观察者在每个循环中，怎么判断是否有事件需要处理呢？这里就要引入观察者了。每个事件循环中都有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。事件循环是一个典型的生产者/消费者模型，异步IO，网络请求等是事件的生产者，源源不断的为Node提供不同类型的事件，这些事件被传递到观察者那里，事件循环则从观察者那里取出事件并处理。 请求对象对于Node中的异步IO调用而言，回调函数不由开发者来调用，从JS发起调用到IO操作完成，存在一个中间产物，叫请求对象。在JS发起调用后，JS调用Node的核心模块，核心模块调用C++内建模块，內建模块通过libuv判断平台并进行系统调用。在进行系统调用时，从JS层传入的方法和参数都被封装在一个请求对象中，请求对象被放在线程池中等待执行。JS立即返回继续下面的操作。 执行回调在线程可用时，线程会取出请求对象来执行IO操作，执行完后将结果放在请求对象中，并归还线程。在事件循环中，IO观察者会不断的找到线程池中已经完成的请求对象，从中取出回调函数和数据并执行 Node中一些非I/O的异步API定时器setTimeout(),setInterval()不需要I/O线程池的作用，创建的定时器对象会被插入到观察者内部的一个红黑树中，每次Tick(一次 循环)执行时，会从该红黑树中迭代取出定时器对象，检查是否超时，如果超过，就形成一个事件，回调函数将立即执行。定时器的问题在于不精确，如果某一次循环占用的时间较多，那么下次循环时，可能就超出时间了。 process.nextTick()将回调函数放入队列中，在下一轮Tick时取出执行。与setTimeout(fn,0)相比，nextTick更加轻量高效，而且定时器精度也不高。 setImmediate()和process.nextTick()很类似。process.nextTick()中的回调函数优先级要高于setImmediate(),原因是事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check对象。在每一轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。具体实现上，process.nextTick()的回调函数保存在一个数组（每轮循环会将数组中的回调函数全部执行完）中，而setimmediate()结果则是保存在链表（在每轮循环中执行链表中的一个回调函数）中。 事件驱动的高性能服务器几种经典服务器模型 同步式：一次只能处理一个请求，其余请求都处于等待状态 每进程/每请求：可以处理多个请求，但是不具备扩展性，因为系统资源有限 每线程/每请求：线程比进程轻量，每个线程都占用一定的内存，大并发，内存仍会用完。（Apacher） 事件驱动的服务器Node和nginx都采用这种事件驱动的服务器。无须为每个请求创建一个额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换代价低，从而实现高性能。","categories":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"}]},{"title":"NodeJS模块机制","slug":"NodeJS模块机制","date":"2017-11-16T14:13:32.000Z","updated":"2018-03-10T07:51:00.000Z","comments":true,"path":"2017/11/16/NodeJS模块机制/","link":"","permalink":"http://colgin.com/2017/11/16/NodeJS模块机制/","excerpt":"CommonJS规范出发点JavaScript存在缺陷，导致在后端其无法用来开发大型应用","text":"CommonJS规范出发点JavaScript存在缺陷，导致在后端其无法用来开发大型应用 没有模块系统 标准库少。文件操作，I/O流都没有标准API 没有标准接口。与web服务器或者数据库的接口 缺乏包管理 具体规范 模块引用 require 模块定义 需要注意的是，上下文提供exports对象用于导出当前模块的方法和变量，并且它是唯一导出的出口。而在模块中还存在一个module对象，它代表模块自身，exports是module的属性。在Node中，一个文件就是一个模块，可以将方法挂载在exports对象上作为属性即可定义导出的方式。 模块标识模块标识就是require()方法的参数，必须是符合小驼峰命名的字符串，或者以 .、..开头的相对路径。可以没有文件后缀.js Node实现引入模块的三个步骤 路径分析 文件定位 编译执行不同类别模块加载的区别 核心模块(Node提供)：在Node源代码编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块直接被加载进内存中(没有文件定位和编译执行的过程)，加载速度很快 文件模块(用户编写)：在运行时动态加载，需要历经路径分析，文件定位，编译执行过程，比核心模块慢一些 路径分析. 核心模块：优先级仅次于缓存加载，被编译成二进制. 路径形式的文件模块(相对定位OR绝对定位)：当成文件模块来处理。转化成真实路径，并且将编译执行后的结果放入缓存中. 自定义模块 自定义模块指的是非核心模块，同时也不是路径形式的标识符。可以认为是一种特殊的文件模块，可能是一个文件或者包的形式，查找比较费时。其实可以理解为你在网络上安装的第三方包。 查找策略 当前目录下的node_modules 父目录下的node_modules 沿路径向上递归，知道根目录下的node_modules 文件定位扩展名分析标识符不包含文件名，Node会按照.js、.node、.json的次序补足，依次尝试 目录分析和包分析完加扩展名的标识符后，可能还没有找到对应文件，但可以得到一个目录。Node会自动将该目录当做一个包来处理。Node（CommonJS规范）首先会在当前目录下找到package.json文件，找到main字段，对该文件名进行定位。如果没有找到，则会将index作为默认文件名，依次查找index.js、index.node、index.json。如果还没有找到则进入下一个模块路径进行同样方式的查找 模块编译Node中每个文件模块都是一个对象。构造函数定义如下1234567891011function Module(id,parent) &#123; this.id = id; this.export = &#123;&#125;; this.parent = parent; if(parent &amp;&amp; parent.children) &#123; parent.children.push(this) &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 不同类型的文件（扩展名不一样），Node会采用不同的读取方式 模块的载入（模块的读取） .js文件。通过fs模块同步读取文件 .node文件。用c/c++编写的扩展文件，通过dlopen()方法加载最后编译生成文件 .json文件。通过fs模块同步读取后，用JSON.parse()解析并且返回结果 其他类型 。按照js文件方法载入 JavaScript模块的编译Node会对获取的JavaScript文件进行头尾包装123456(function(exports,require,module,__filename,__dirname) &#123; var math = require('math') exports.add = function() &#123; &#125;&#125;); 然后通过vm原生模块的runInThisContenxt()方法执行（类似eval，但是有明确上下文，不污染全局环境），返回一个function对象，最后将当前模块对象的exports，require…等参数传入这个function()执行。执行之后，模块的exports属性会返回给调用方 这也是为什么这些变量没有定义在模块文件，却可以使用的原因。同时需要注意的是这里的module.exports 和 exports之间的关系。在模块内部是不能直接将值赋给exports对象，因为exports对象是通过形参的方式传入函数的，直接赋值会改变形参的引用，但并不能改变作用域外的值。所以应该将值以属性的方式赋进去，或者直接赋值给module.exports对象 c/c++模块编译Node会调用process.dlopen()方法进行加载和执行。Node架构下，dlopen()方法在windows和Linux平台下分别有不同实现。通过libuv兼容层进行了封装 JSON文件的编译通过JSON.parse()把通过fs模块异步读取的内容传入，即可得到对象，然后将对象赋给模块对象的exports，以供外部使用。一般对于配置文件，可以直接require(),无需fs读取。 包和NPMCommonJS规范定义的包结构 package.json：包描述文件 bin ：存放可执行二进制文件 lib：存放JS代码 doc：存放文档 test：存放单元测试代码 CommonJS和NPM的包描述文件 需要注意的是，CommonJS规范的package.json字段和NPM所实现的package.json字段略微有些差别。NPM在CommonJS的基础上添加了一些字段 几个字段解释 bin：一些包作者希望包可以作为命令行工具使用，配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行 main：模板引入方法require()在引入包时，会有限检查这个字段，并将其作为包中其余模块的入口 devDependencies：一些模块只在开发时需要依赖 engine：支持的JavaScript引擎列表，ejs，ppc，mips，jsc，node，v8等 NPM常用功能 安装依赖包：npm install 全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以在任何地方通过require()都能引用到它。实际上，全局安装时将一个包安装为全局可用的可执行命令，它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同路径下（全局模式安装的所有模块宝都被安装进了一个统一的目录下，这个目录是path.resolve(process.execPath,&#39;..&#39;,&#39;..&#39;,&#39;lib&#39;,&#39;node_modules&#39;)这里process.execPath是node的安装目录，由于环境变量的作用，在任何目录下执行node命令都会链接到node安装目录） 查看可用包：npm ls 分析出当前路径通过模块路径找到的所有包，并生成依赖树 NPM的问题每个人都可以向npm仓库发布包，导致包的质量良莠不齐，一个可靠的，优秀的包必须有良好的测试，良好的文档，良好的测试覆盖率，良好的编码规范等等","categories":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://colgin.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://colgin.com/tags/JavaScript/"}]},{"title":"为Hexo + Yilia的博客上添加livere(来必利)作为评论支持","slug":"为Hexo-Yilia的博客上添加livere-来必利-作为评论支持","date":"2017-07-23T08:06:02.000Z","updated":"2017-11-16T15:11:48.000Z","comments":true,"path":"2017/07/23/为Hexo-Yilia的博客上添加livere-来必利-作为评论支持/","link":"","permalink":"http://colgin.com/2017/07/23/为Hexo-Yilia的博客上添加livere-来必利-作为评论支持/","excerpt":"在搭建好博客之后，总感觉少了点什么，看了看别人的博客，恍然大悟，没有评论的博客哪能叫博客啊，要是别人发现你的博客有错，都没法联系你。于是就开始琢磨给博客添加评论。 由于我之前选用的是Yilia，在这个主题中提供了几种参考的评论系统（网易云跟帖，多说，disqus，畅言），本着学习 + 实践的态度。我开始了试错之路。","text":"在搭建好博客之后，总感觉少了点什么，看了看别人的博客，恍然大悟，没有评论的博客哪能叫博客啊，要是别人发现你的博客有错，都没法联系你。于是就开始琢磨给博客添加评论。 由于我之前选用的是Yilia，在这个主题中提供了几种参考的评论系统（网易云跟帖，多说，disqus，畅言），本着学习 + 实践的态度。我开始了试错之路。 多说 以前用的比较多，不过现在关了。网易云跟帖 不多说了Disqus 这个在国外用的比较多，也是当之无愧的行业老大，但是它被墙了，没有梯子用不了，所以放弃。畅言 畅言是搜狐旗下额产品，功能还是挺不错，但是样式就各有各的看法咯！另外要注意一点的是，使用畅言必须要备案，不备案的话是用不了的。由于我使用的是git page，属于二级域名，自然也就用不了畅言了。如果你买了域名，同时也备案了，我觉得可是试一试。友言 样式还是比较好看的，不过要注意的是友言使用的是HTTP协议，如果你的博客使用的是HTTPS协议(git page就是如此)的话，也是用不了的(HTTP请求会被浏览器禁掉)，这里要特别注意。（livere）来比力 来自韩国的产品，UI比较现代化吧感觉。支持QQ，微信，微博，GitHub等多种登录方式，不需要备案，使用HTTPS协议，因此我选用它来作为我的评论模块。以下是介绍在Hexo + Yilia主题的博客中使用livere。livere使用方法注册livere 登录liver官网 填写相关信息 livere提供两个版本 City版：一款适合所有人使用的免费版本 Premium版：一款能够帮助企业实现自动化管理的多功能收费版本 在管理页面-&gt;代码管理-&gt;一般网站，复制那一段代码到粘贴板 在博客中配置插件 打开 根目录\\themes\\yilia_config.yml，然后在里面添加一项 1livere: true 注意:后面有一个空格 在根目录\\themes\\yilia\\layout_partial\\post目录下添加一个livere.ejs文件写入之前在liver后台生成的那一段代码 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;your data-uid&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; （其实这一段也就是在之前步骤里的管理页面-&gt;代码管理-&gt;一般网站那一段代码） 打开位于在博客根目录\\themes\\yilia\\layout_partial目录下的artical.ejs。找到判断主题的那个地方（在&lt;% if (!index &amp;&amp; post.comments){ %&gt;后），添加如下代码 1234567&lt;% if (theme.livere)&#123; %&gt; &lt;%- partial(&apos;post/livere&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt; 进行到这一步，插件的配置也就结束了 重新构建博客在博客根目录下执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。重新构建网站，然后等一会，你就可以看到效果了。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://colgin.com/tags/博客搭建/"}]},{"title":"我的个人博客终于搭建好了···（撒花）","slug":"我的个人博客终于搭建好了···（撒花）","date":"2017-07-17T08:35:00.000Z","updated":"2017-07-23T12:15:26.000Z","comments":true,"path":"2017/07/17/我的个人博客终于搭建好了···（撒花）/","link":"","permalink":"http://colgin.com/2017/07/17/我的个人博客终于搭建好了···（撒花）/","excerpt":"","text":"欢迎进入我的个人博客。","categories":[],"tags":[]}]}