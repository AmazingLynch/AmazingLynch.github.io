{"meta":{"title":"Lynch's Blogs","subtitle":"记录生活与学习的点点滴滴","description":"个人博客","author":"AmazingLynch","url":"http://amazinglynch.com"},"pages":[{"title":"categories","date":"2017-11-16T14:55:09.000Z","updated":"2017-11-16T14:56:28.812Z","comments":false,"path":"categories/index.html","permalink":"http://amazinglynch.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-16T14:45:52.000Z","updated":"2017-11-16T14:55:53.184Z","comments":false,"path":"tags/index.html","permalink":"http://amazinglynch.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NodeJS异步IO","slug":"NodeJS异步IO","date":"2017-11-17T03:37:16.000Z","updated":"2017-11-17T14:33:28.899Z","comments":true,"path":"2017/11/17/NodeJS异步IO/","link":"","permalink":"http://amazinglynch.com/2017/11/17/NodeJS异步IO/","excerpt":"提到Node，我们很容易想到异步IO，但是什么是异步IO？为什么要用异步IO？异步IO执行流程是怎么样的？你真的了解Node中的异步IO吗？","text":"提到Node，我们很容易想到异步IO，但是什么是异步IO？为什么要用异步IO？异步IO执行流程是怎么样的？你真的了解Node中的异步IO吗？ 导读异步IO其实并不是一个新鲜的概念，它早就存在于操作系统中，但是由于使用异步的编程模式不太好理解，以至于一些高级语言典型如PHP，在语言层面屏蔽了异步甚至是多线程，PHP是以同步阻塞的方式来运行的，这种设计的优点在于，程序员同步编写代码，代码很好理解。缺点在于阻塞导致其不能很好的并发。Node的设计理念是事件驱动，异步I/O。 为什么需要异步I/O用户体验首先我们要知道的是浏览器中的JavaScript是在单线程上执行，而且它还是与UI渲染共用一个线程。这就意味着JavaScript在执行过程的时候UI渲染和响应处于停滞状态（所以脚本执行时间不能过长）。需要注意的是B/S模型总，网络速度会给用户体验带来很大麻烦。如果以同步方式获取服务器上的资源，JavaScript会停住等待，这期间UI会停顿，交互不能响应。 同步和异步运行时间比较1234567//同步方式运行，总共耗时M+NgetDate(url1) //耗时MgetDate(url2) //耗时N//异步方式运行，总共耗时max(M,N)getDate(url1,function(result) &#123;&#125;)//耗时MgetDate(url2,function(result) &#123;&#125;)//耗时N 资源分配 需要了解的是，如果有一组互不相关的任务需要完成，主流的方法有两个，单线程串行执行和多线程并行的区别。多线程的代价在于执行期线程上下文切换开销比较大。在业务复杂的时候，还经常面临锁，状态同步的问题。有点在于在多核cpu上能够有效提升cpu利用率。单线程优点在于编程方式比较符合人的思维习惯，易于表达。缺点在于其性能不是很好，一个略慢的任务会导致后续执行代码被阻塞。在计算机资源中，通常I/O与CPU计算之间是可以并行进行的。但是同步编程却使得I/O操作让后续任务等待，造成资源不能很好的利用。 Node在单线程同步和多线程并行之间选择的方案是：利用单线程，远离死锁，状态同步的问题，利用异步，远离单线程阻塞的问题，更好利用cpu。 另外Node为了弥补单线程无法利用多核CPU的缺点，也提供了类似前端web workers的子进程。该子进程可以通过工作进程高效利用CPU和I/O。 异步I/O与非阻塞I/O异步I/O ≠ 非阻塞I/O同步/异步和阻塞/非阻塞是两回事。对操作系统内核I/O来说，只有阻塞I/O和非阻塞I/O。 阻塞I/O：调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。以读文件为例，磁盘寻道，读取数据，复制数据到内存中，调用结束 非阻塞I/O：调用之后立即返回，返回的不是业务层期望的数据，而是当前调用的状态，如果要获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。（重复确认-&gt;轮询），其麻烦的地方在于需要采用轮询技术去确认是否完成数据获取。cpu判断，耗费cpu资源。轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于应用程序来说，这只能算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧会需要很多时间来等待。理想情况下的非阻塞异步I/O应该是应用程序发起非阻塞调用，无需通过遍历或者时间唤醒等待方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或者回调将数据传递给应用程序即可。 现实的异步I/O通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让另一个线程进行计算处理，通过线程之间的通信将I/O得到得数据进行传递，这种便是典型的线程池模拟异步I/O。典型的*nix下的libeio和windows下的IOCP都是使用这种方式，而Node提供了libuv作为抽象封装层，使得Node支持跨平台异步I/O。 需要注意的是，我们常说Node是单线程的，指的是JavaScript执行在单线程中，在Node中，无论在什么平台，内部完成I/O任务都另有线程池。除了用户代码无法并行执行外，所有的I/O则是可以并行起来的 Node中的异步I/O事件循环（event loop）整个Node执行都在一个事件循环中 观察者在每个循环中，怎么判断是否有事件需要处理呢？这里就要引入观察者了。每个事件循环中都有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。事件循环是一个典型的生产者/消费者模型，异步IO，网络请求等是事件的生产者，源源不断的为Node提供不同类型的事件，这些事件被传递到观察者那里，事件循环则从观察者那里取出事件并处理。 请求对象对于Node中的异步IO调用而言，回调函数不由开发者来调用，从JS发起调用到IO操作完成，存在一个中间产物，叫请求对象。在JS发起调用后，JS调用Node的核心模块，核心模块调用C++内建模块，內建模块通过libuv判断平台并进行系统调用。在进行系统调用时，从JS层传入的方法和参数都被封装在一个请求对象中，请求对象被放在线程池中等待执行。JS立即返回继续下面的操作。 执行回调在线程可用时，线程会取出请求对象来执行IO操作，执行完后将结果放在请求对象中，并归还线程。在事件循环中，IO观察者会不断的找到线程池中已经完成的请求对象，从中取出回调函数和数据并执行 Node中一些非I/O的异步API定时器setTimeout(),setInterval()不需要I/O线程池的作用，创建的定时器对象会被插入到观察者内部的一个红黑树中，每次Tick(一次 循环)执行时，会从该红黑树中迭代取出定时器对象，检查是否超时，如果超过，就形成一个事件，回调函数将立即执行。定时器的问题在于不精确，如果某一次循环占用的时间较多，那么下次循环时，可能就超出时间了。 process.nextTick()将回调函数放入队列中，在下一轮Tick时取出执行。与setTimeout(fn,0)相比，nextTick更加轻量高效，而且定时器精度也不高。 setImmediate()和process.nextTick()很类似。process.nextTick()中的回调函数优先级要高于setImmediate(),原因是事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check对象。在每一轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。具体实现上，process.nextTick()的回调函数保存在一个数组（每轮循环会将数组中的回调函数全部执行完）中，而setimmediate()结果则是保存在链表（在每轮循环中执行链表中的一个回调函数）中。 事件驱动的高性能服务器几种经典服务器模型 同步式：一次只能处理一个请求，其余请求都处于等待状态 每进程/每请求：可以处理多个请求，但是不具备扩展性，因为系统资源有限 每线程/每请求：线程比进程轻量，每个线程都占用一定的内存，大并发，内存仍会用完。（Apacher） 事件驱动的服务器Node和nginx都采用这种事件驱动的服务器。无须为每个请求创建一个额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换代价低，从而实现高性能。","categories":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://amazinglynch.com/tags/JavaScript/"}]},{"title":"NodeJS模块机制","slug":"NodeJS模块机制","date":"2017-11-16T14:13:32.000Z","updated":"2017-11-17T03:08:20.574Z","comments":true,"path":"2017/11/16/NodeJS模块机制/","link":"","permalink":"http://amazinglynch.com/2017/11/16/NodeJS模块机制/","excerpt":"CommonJS规范出发点JavaScript存在缺陷，导致在后端其无法用来开发大型应用","text":"CommonJS规范出发点JavaScript存在缺陷，导致在后端其无法用来开发大型应用 没有模块系统 标准库少。文件操作，I/O流都没有标准API 没有标准接口。与web服务器或者数据库的接口 缺乏包管理 具体规范 模块引用 require 模块定义 需要注意的是，上下文提供exports对象用于导出当前模块的方法和变量，并且它是唯一导出的出口。而在模块中还存在一个module对象，它代表模块自身，exports是module的属性。在Node中，一个文件就是一个模块，可以将方法挂载在exports对象上作为属性即可定义导出的方式。 模块标识模块标识就是require()方法的参数，必须是符合小驼峰命名的字符串，或者以 .、..开头的相对路径。可以没有文件后缀.js Node实现引入模块的三个步骤 路径分析 文件定位 编译执行不同类别模块加载的区别 核心模块(Node提供)：在Node源代码编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块直接被加载进内存中(没有文件定位和编译执行的过程)，加载速度很快 文件模块(用户编写)：在运行时动态加载，需要历经路径分析，文件定位，编译执行过程，比核心模块慢一些 路径分析. 核心模块：优先级仅次于缓存加载，被编译成二进制. 路径形式的文件模块(相对定位OR绝对定位)：当成文件模块来处理。转化成真实路径，并且将编译执行后的结果放入缓存中. 自定义模块 自定义模块指的是非核心模块，同时也不是路径形式的标识符。可以认为是一种特殊的文件模块，可能是一个文件或者包的形式，查找比较费时。 查找策略 当前目录下的node_modules 父目录下的node_modules 沿路径向上递归，知道根目录下的node_modules 文件定位扩展名分析标识符不包含文件名，Node会按照.js、.node、.json的次序补足，依次尝试 目录分析和包分析完加扩展名的标识符后，可能还没有找到对应文件，但可以得到一个目录。Node会自动将该目录当做一个包来处理。Node（CommonJS规范）首先会在当前目录下找到package.json文件，找到main字段，对该文件名进行定位。如果没有找到，则会将index作为默认文件名，依次查找index.js、index.node、index.json。如果还没有找到则进入下一个模块路径进行同样方式的查找 模块编译Node中每个文件模块都是一个对象。构造函数定义如下1234567891011function Module(id,parent) &#123; this.id = id; this.export = &#123;&#125;; this.parent = parent; if(parent &amp;&amp; parent.children) &#123; parent.children.push(this) &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 不同类型的文件（扩展名不一样），Node会采用不同的读取方式 模块的载入（模块的读取） .js文件。通过fs模块同步读取文件 .node文件。用c/c++编写的扩展文件，通过dlopen()方法加载最后编译生成文件 .json文件。通过fs模块同步读取后，用JSON.parse()解析并且返回结果 其他类型 。按照js文件方法载入 JavaScript模块的编译Node会对获取的JavaScript文件进行头尾包装123456(function(exports,require,module,__filename,__dirname) &#123; var math = require('math') exports.add = function() &#123; &#125;&#125;); 然后通过vm原生模块的runInThisContenxt()方法执行（类似eval，但是有明确上下文，不污染全局环境），返回一个function对象，最后将当前模块对象的exports，require…等参数传入这个function()执行。执行之后，模块的exports属性会返回给调用方 这也是为什么这些变量没有定义在模块文件，却可以使用的原因。同时需要注意的是这里的module.exports 和 exports之间的关系。在模块内部是不能直接将值赋给exports对象，因为exports对象是通过形参的方式传入函数的，直接赋值会改变形参的引用，但并不能改变作用域外的值。所以应该将值以属性的方式赋进去，或者直接赋值给module.exports对象 c/c++模块编译Node会调用process.dlopen()方法进行加载和执行。Node架构下，dlopen()方法在windows和Linux平台下分别有不同实现。通过libuv兼容层进行了封装 JSON文件的编译通过JSON.parse()把通过fs模块异步读取的内容传入，即可得到对象，然后将对象赋给模块对象的exports，以供外部使用。一般对于配置文件，可以直接require(),无需fs读取。 包和NPMCommonJS规范定义的包结构 package.json：包描述文件 bin ：存放可执行二进制文件 lib：存放JS代码 doc：存放文档 test：存放单元测试代码 CommonJS和NPM的包描述文件 需要注意的是，CommonJS规范的package.json字段和NPM所实现的package.json字段略微有些差别。NPM在CommonJS的基础上添加了一些字段 几个字段解释 bin：一些包作者希望包可以作为命令行工具使用，配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行 main：模板引入方法require()在引入包时，会有限检查这个字段，并将其作为包中其余模块的入口 devDependencies：一些模块只在开发时需要依赖 engine：支持的JavaScript引擎列表，ejs，ppc，mips，jsc，node，v8等 NPM常用功能 安装依赖包：npm install 全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以在任何地方通过require()都能引用到它。实际上，全局安装时将一个包安装为全局可用的可执行命令，它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同路径下（全局模式安装的所有模块宝都被安装进了一个统一的目录下，这个目录是path.resolve(process,execPath,&#39;..&#39;,&#39;..&#39;,&#39;lib&#39;,&#39;node_modules&#39;)这里process.execPath是node的安装目录，由于环境变量的作用，在任何目录下执行node命令都会链接到node安装目录） 查看可用包：npm ls 分析出当前路径通过模块路径找到的所有包，并生成依赖树 NPM的问题每个人都可以向npm仓库发布包，导致包的质量良莠不齐，一个可靠的，优秀的包必须有良好的测试，良好的文档，良好的测试覆盖率，良好的编码规范等等","categories":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://amazinglynch.com/tags/JavaScript/"}]},{"title":"为Hexo + Yilia的博客上添加livere(来必利)作为评论支持","slug":"为Hexo-Yilia的博客上添加livere-来必利-作为评论支持","date":"2017-07-23T08:06:02.000Z","updated":"2017-11-16T15:11:48.601Z","comments":true,"path":"2017/07/23/为Hexo-Yilia的博客上添加livere-来必利-作为评论支持/","link":"","permalink":"http://amazinglynch.com/2017/07/23/为Hexo-Yilia的博客上添加livere-来必利-作为评论支持/","excerpt":"在搭建好博客之后，总感觉少了点什么，看了看别人的博客，恍然大悟，没有评论的博客哪能叫博客啊，要是别人发现你的博客有错，都没法联系你。于是就开始琢磨给博客添加评论。 由于我之前选用的是Yilia，在这个主题中提供了几种参考的评论系统（网易云跟帖，多说，disqus，畅言），本着学习 + 实践的态度。我开始了试错之路。","text":"在搭建好博客之后，总感觉少了点什么，看了看别人的博客，恍然大悟，没有评论的博客哪能叫博客啊，要是别人发现你的博客有错，都没法联系你。于是就开始琢磨给博客添加评论。 由于我之前选用的是Yilia，在这个主题中提供了几种参考的评论系统（网易云跟帖，多说，disqus，畅言），本着学习 + 实践的态度。我开始了试错之路。 多说 以前用的比较多，不过现在关了。网易云跟帖 不多说了Disqus 这个在国外用的比较多，也是当之无愧的行业老大，但是它被墙了，没有梯子用不了，所以放弃。畅言 畅言是搜狐旗下额产品，功能还是挺不错，但是样式就各有各的看法咯！另外要注意一点的是，使用畅言必须要备案，不备案的话是用不了的。由于我使用的是git page，属于二级域名，自然也就用不了畅言了。如果你买了域名，同时也备案了，我觉得可是试一试。友言 样式还是比较好看的，不过要注意的是友言使用的是HTTP协议，如果你的博客使用的是HTTPS协议(git page就是如此)的话，也是用不了的(HTTP请求会被浏览器禁掉)，这里要特别注意。（livere）来比力 来自韩国的产品，UI比较现代化吧感觉。支持QQ，微信，微博，GitHub等多种登录方式，不需要备案，使用HTTPS协议，因此我选用它来作为我的评论模块。以下是介绍在Hexo + Yilia主题的博客中使用livere。livere使用方法注册livere 登录liver官网 填写相关信息 livere提供两个版本 City版：一款适合所有人使用的免费版本 Premium版：一款能够帮助企业实现自动化管理的多功能收费版本 在管理页面-&gt;代码管理-&gt;一般网站，复制那一段代码到粘贴板 在博客中配置插件 打开 根目录\\themes\\yilia_config.yml，然后在里面添加一项 1livere: true 注意:后面有一个空格 在根目录\\themes\\yilia\\layout_partial\\post目录下添加一个livere.ejs文件写入之前在liver后台生成的那一段代码 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;your data-uid&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; （其实这一段也就是在之前步骤里的管理页面-&gt;代码管理-&gt;一般网站那一段代码） 打开位于在博客根目录\\themes\\yilia\\layout_partial目录下的artical.ejs。找到判断主题的那个地方（在&lt;% if (!index &amp;&amp; post.comments){ %&gt;后），添加如下代码 1234567&lt;% if (theme.livere)&#123; %&gt; &lt;%- partial(&apos;post/livere&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt; 进行到这一步，插件的配置也就结束了 重新构建博客在博客根目录下执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。重新构建网站，然后等一会，你就可以看到效果了。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://amazinglynch.com/tags/博客搭建/"}]},{"title":"我的个人博客终于搭建好了···（撒花）","slug":"我的个人博客终于搭建好了···（撒花）","date":"2017-07-17T08:35:00.000Z","updated":"2017-07-23T12:15:27.477Z","comments":true,"path":"2017/07/17/我的个人博客终于搭建好了···（撒花）/","link":"","permalink":"http://amazinglynch.com/2017/07/17/我的个人博客终于搭建好了···（撒花）/","excerpt":"","text":"欢迎进入我的个人博客。","categories":[],"tags":[]}]}