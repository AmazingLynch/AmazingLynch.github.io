{"meta":{"title":"Lynch","subtitle":"记录生活与学习的点点滴滴","description":"个人博客","author":"AmazingLynch","url":"http://amazinglynch.com"},"pages":[],"posts":[{"title":"NodeJS模块机制","slug":"NodeJS模块机制","date":"2017-11-16T14:13:32.000Z","updated":"2017-11-16T14:26:20.910Z","comments":true,"path":"2017/11/16/NodeJS模块机制/","link":"","permalink":"http://amazinglynch.com/2017/11/16/NodeJS模块机制/","excerpt":"CommonJS规范出发点JavaScript存在缺陷，导致在后端其无法用来开发大型应用","text":"CommonJS规范出发点JavaScript存在缺陷，导致在后端其无法用来开发大型应用 没有模块系统 标准库少。文件操作，I/O流都没有标准API 没有标准接口。与web服务器或者数据库的接口 缺乏包管理 具体规范 模块引用 require 模块定义 需要注意的是，上下文提供exports对象用于导出当前模块的方法和变量，并且它是唯一导出的出口。而在模块中还存在一个module对象，它代表模块自身，exports是module的属性。在Node中，一个文件就是一个模块，可以将方法挂载在exports对象上作为属性即可定义导出的方式。 模块标识模块标识就是require()方法的参数，必须是符合小驼峰命名的字符串，或者以 .、..开头的相对路径。可以没有文件后缀.js Node实现引入模块的三个步骤 路径分析 文件定位 编译执行不同类别模块加载的区别 核心模块(Node提供)：在Node源代码编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块直接被加载进内存中(没有文件定位和编译执行的过程)，加载速度很快 文件模块(用户编写)：在运行时动态加载，需要历经路径分析，文件定位，编译执行过程，比核心模块慢一些 路径分析. 核心模块：优先级仅次于缓存加载，被编译成二进制. 路径形式的文件模块(相对定位OR绝对定位)：当成文件模块来处理。转化成真实路径，并且将编译执行后的结果放入缓存中. 自定义模块 自定义模块指的是非核心模块，同时也不是路径形式的标识符。可以认为是一种特殊的文件模块，可能是一个文件或者包的形式，查找比较费时。 查找策略 当前目录下的node_modules 父目录下的node_modules 沿路径向上递归，知道根目录下的node_modules 文件定位扩展名分析标识符不包含文件名，Node会按照.js、.node、.json的次序补足，依次尝试 目录分析和包分析完加扩展名的标识符后，可能还没有找到对应文件，但可以得到一个目录。Node会自动将该目录当做一个包来处理。Node（CommonJS规范）首先会在当前目录下找到package.json文件，找到main字段，对该文件名进行定位。如果没有找到，则会将index作为默认文件名，依次查找index.js、index.node、index.json。如果还没有找到则进入下一个模块路径进行同样方式的查找 模块编译Node中每个文件模块都是一个对象。构造函数定义如下1234567891011function Module(id,parent) &#123; this.id = id; this.export = &#123;&#125;; this.parent = parent; if(parent &amp;&amp; parent.children) &#123; parent.children.push(this) &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 不同类型的文件（扩展名不一样），Node会采用不同的读取方式 模块的载入（模块的读取） [ ] .js文件。通过fs模块同步读取文件 [ ] .node文件。用c/c++编写的扩展文件，通过dlopen()方法加载最后编译生成文件 [ ] .json文件。通过fs模块同步读取后，用JSON.parse()解析并且返回结果 [ ] 其他类型 。按照js文件方法载入 JavaScript模块的编译Node会对获取的JavaScript文件进行头尾包装123456(function(exports,require,module,__filename,__dirname) &#123; var math = require('math') exports.add = function() &#123; &#125;&#125;); 然后通过vm原生模块的runInThisContenxt()方法执行（类似eval，但是有明确上下文，不污染全局环境），返回一个function对象，最后将当前模块对象的exports，require…等参数传入这个function()执行。执行之后，模块的exports属性会返回给调用方 这也是为什么这些变量没有定义在模块文件，却可以使用的原因。同时需要注意的是这里的module.exports 和 exports之间的关系。在模块内部是不能直接将值赋给exports对象，因为exports对象是通过形参的方式传入函数的，直接赋值会改变形参的引用，但并不能改变作用域外的值。所以应该将值以属性的方式赋进去，或者直接赋值给module.exports对象 c/c++模块编译Node会调用process.dlopen()方法进行加载和执行。Node架构下，dlopen()方法在windows和Linux平台下分别有不同实现。通过libuv兼容层进行了封装 JSON文件的编译通过JSON.parse()把通过fs模块异步读取的内容传入，即可得到对象，然后将对象赋给模块对象的exports，以供外部使用。一般对于配置文件，可以直接require(),无需fs读取。 包和NPMCommonJS规范定义的包结构 [ ] package.json：包描述文件 [ ] bin ：存放可执行二进制文件 [ ] lib：存放JS代码 [ ] doc：存放文档 [ ] test：存放单元测试代码 CommonJS和NPM的包描述文件 需要注意的是，CommonJS规范的package.json字段和NPM所实现的package.json字段略微有些差别。NPM在CommonJS的基础上添加了一些字段 几个字段解释 [ ] bin：一些包作者希望包可以作为命令行工具使用，配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行 [ ] main：模板引入方法require()在引入包时，会有限检查这个字段，并将其作为包中其余模块的入口 [ ] devDependencies：一些模块只在开发时需要依赖 [ ] engine：支持的JavaScript引擎列表，ejs，ppc，mips，jsc，node，v8等 NPM常用功能 安装依赖包：npm install 全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以在任何地方通过require()都能引用到它。实际上，全局安装时将一个包安装为全局可用的可执行命令，它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同路径下（全局模式安装的所有模块宝都被安装进了一个统一的目录下，这个目录是path.resolve(process,execPath,&#39;..&#39;,&#39;..&#39;,&#39;lib&#39;,&#39;node_modules&#39;)这里process.execPath是node的安装目录，由于环境变量的作用，在任何目录下执行node命令都会链接到node安装目录） 查看可用包：npm ls 分析出当前路径通过模块路径找到的所有包，并生成依赖树 NPM的问题每个人都可以向npm仓库发布包，导致包的质量良莠不齐，一个可靠的，优秀的包必须有良好的测试，良好的文档，良好的测试覆盖率，良好的编码规范等等","categories":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://amazinglynch.com/tags/Node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://amazinglynch.com/tags/JavaScript/"}]},{"title":"为Hexo + Yilia的博客上添加livere(来必利)作为评论支持","slug":"为Hexo-Yilia的博客上添加livere-来必利-作为评论支持","date":"2017-07-23T08:06:02.000Z","updated":"2017-07-23T12:45:39.293Z","comments":true,"path":"2017/07/23/为Hexo-Yilia的博客上添加livere-来必利-作为评论支持/","link":"","permalink":"http://amazinglynch.com/2017/07/23/为Hexo-Yilia的博客上添加livere-来必利-作为评论支持/","excerpt":"","text":"在搭建好博客之后，总感觉少了点什么，看了看别人的博客，恍然大悟，没有评论的博客哪能叫博客啊，要是别人发现你的博客有错，都没法联系你。于是就开始琢磨给博客添加评论。 由于我之前选用的是Yilia，在这个主题中提供了几种参考的评论系统（网易云跟帖，多说，disqus，畅言），本着学习 + 实践的态度。我开始了试错之路。 多说 以前用的比较多，不过现在关了。网易云跟帖 不多说了Disqus 这个在国外用的比较多，也是当之无愧的行业老大，但是它被墙了，没有梯子用不了，所以放弃。畅言 畅言是搜狐旗下额产品，功能还是挺不错，但是样式就各有各的看法咯！另外要注意一点的是，使用畅言必须要备案，不备案的话是用不了的。由于我使用的是git page，属于二级域名，自然也就用不了畅言了。如果你买了域名，同时也备案了，我觉得可是试一试。友言 样式还是比较好看的，不过要注意的是友言使用的是HTTP协议，如果你的博客使用的是HTTPS协议(git page就是如此)的话，也是用不了的(HTTP请求会被浏览器禁掉)，这里要特别注意。（livere）来比力 来自韩国的产品，UI比较现代化吧感觉。支持QQ，微信，微博，GitHub等多种登录方式，不需要备案，使用HTTPS协议，因此我选用它来作为我的评论模块。以下是介绍在Hexo + Yilia主题的博客中使用livere。livere使用方法注册livere 登录liver官网 填写相关信息 livere提供两个版本 City版：一款适合所有人使用的免费版本 Premium版：一款能够帮助企业实现自动化管理的多功能收费版本 在管理页面-&gt;代码管理-&gt;一般网站，复制那一段代码到粘贴板 在博客中配置插件 打开 根目录\\themes\\yilia_config.yml，然后在里面添加一项1livere: true 注意:后面有一个空格 在根目录\\themes\\yilia\\layout_partial\\post目录下添加一个livere.ejs文件写入之前在liver后台生成的那一段代码123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;your data-uid&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; （其实这一段也就是在之前步骤里的管理页面-&gt;代码管理-&gt;一般网站那一段代码） 打开位于在博客根目录\\themes\\yilia\\layout_partial目录下的artical.ejs。找到判断主题的那个地方（在&lt;% if (!index &amp;&amp; post.comments){ %&gt;后），添加如下代码1234567&lt;% if (theme.livere)&#123; %&gt; &lt;%- partial(&apos;post/livere&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt; 进行到这一步，插件的配置也就结束了 重新构建博客在博客根目录下执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d。重新构建网站，然后等一会，你就可以看到效果了。","categories":[],"tags":[]},{"title":"我的个人博客终于搭建好了···（撒花）","slug":"我的个人博客终于搭建好了···（撒花）","date":"2017-07-17T08:35:00.000Z","updated":"2017-07-23T12:15:27.477Z","comments":true,"path":"2017/07/17/我的个人博客终于搭建好了···（撒花）/","link":"","permalink":"http://amazinglynch.com/2017/07/17/我的个人博客终于搭建好了···（撒花）/","excerpt":"","text":"欢迎进入我的个人博客。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-07-17T08:04:01.464Z","updated":"2017-07-17T08:04:01.464Z","comments":true,"path":"2017/07/17/hello-world/","link":"","permalink":"http://amazinglynch.com/2017/07/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}